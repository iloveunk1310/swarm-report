% sections/firefly_algorithm.tex – Firefly Algorithm section

\section{Firefly Algorithm}

\subsection{Giới thiệu}

\subsubsection{Ý tưởng cốt lõi \cite{yang2010firefly}}
Thuật toán Đom Đóm (Firefly Algorithm, FA) là một metaheuristic lấy cảm hứng từ hành vi phát quang và bị hút lẫn nhau của đom đóm trong tự nhiên. Trong FA, mỗi nghiệm ứng viên là một ``đom đóm'' với \emph{độ sáng} (brightness) tỉ lệ với \emph{độ phù hợp} (fitness). Một đom đóm kém sáng sẽ di chuyển về phía đom đóm sáng hơn; cường độ \emph{hấp dẫn} suy giảm theo khoảng cách. Thành phần \emph{nhiễu} (randomization) được thêm vào để tăng khả năng thoát bẫy cục bộ và thăm dò không gian nghiệm rộng hơn. Cơ chế này tạo nên sự cân bằng \emph{thăm dò} (exploration) và \emph{khai thác} (exploitation), phù hợp với các bài toán đa cực trị (multimodal) (Yang, 2009; Yang \& He, 2013).

\subsubsection{Lịch sử ngắn gọn}
FA được đề xuất bởi Xin-She Yang vào giai đoạn 2008--2009 và nhanh chóng trở thành một trong các thuật toán tối ưu lấy cảm hứng tự nhiên tiêu biểu bên cạnh PSO, BA, Cuckoo Search, v.v. (Yang, 2009; Yang, 2010). Hướng phát triển gồm: FA tự điều chỉnh tham số, FA lai (hybrid) với tìm kiếm cục bộ, FA song song/đám mây, và các biến thể \emph{rời rạc hoá} cho bài toán tổ hợp (Yang \& He, 2013; Baykasoğlu et al., 2014).

\subsubsection{Ứng dụng tiêu biểu}
FA được áp dụng rộng rãi trong: tối ưu hàm chuẩn (Rastrigin, Ackley, Rosenbrock), điều chỉnh siêu tham số mô hình học máy, chọn đặc trưng, định tuyến--lập lịch, và các bài toán tổ hợp như Knapsack/Flow-Shop sau khi rời rạc hoá (\emph{binarization} hoặc \emph{discretization}) (Yang, 2010; Yang \& He, 2013). Điểm mạnh chính: (i) công thức cập nhật đơn giản; (ii) ít siêu tham số; (iii) linh hoạt để thích nghi với cả không gian liên tục và nhị phân.

\subsection{Cơ sở toán học của thuật toán}
\subsubsection{Mô hình gốc \cite{tilahun2019continuous}}
Xét bài toán cực tiểu hoá không ràng buộc
\[
\min_{x \in \mathbb{R}^d} f(x).
\]
Tại vòng lặp $t$, cá thể $i$ có vị trí $\mathbf{x}_i^{(t)} \in \mathbb{R}^d$. Gọi $r_{ij}^{(t)} = \| \mathbf{x}_i^{(t)} - \mathbf{x}_j^{(t)} \|_2$ là khoảng cách giữa $i$ và $j$.

\paragraph{Độ sáng (Brightness).}

Độ sáng của mỗi đom đóm được tính từ fitness:
\[
I_i = -f(\mathbf{x}_i) \quad \text{(bài toán cực tiểu)}
\]
Đom đóm có fitness tốt hơn (giá trị $f$ nhỏ hơn) sẽ sáng hơn.

\paragraph{Hấp dẫn suy giảm theo khoảng cách.}

Hàm hấp dẫn chuẩn trong FA:
\[
\beta\!\left(r_{ij}^{(t)}\right) \;=\; \beta_0 \exp\!\big(-\gamma \, (r_{ij}^{(t)})^2\big),
\]
trong đó $\beta_0>0$ là hấp dẫn tại $r=0$, còn $\gamma>0$ điều khiển mức suy giảm theo khoảng cách (Yang, 2009).

\paragraph{Quy tắc cập nhật (không gian liên tục).}

Đối với mỗi đom đóm $i$, chỉ di chuyển về phía các đom đóm sáng hơn:
\[
\mathbf{x}_i^{(t+1)}
= \mathbf{x}_i^{(t)}
+ \beta\!\left(r_{ij}^{(t)}\right)\,\big(\mathbf{x}_j^{(t)} - \mathbf{x}_i^{(t)}\big)
+ \alpha \,\boldsymbol{\varepsilon}_i^{(t)}.
\]
khi $I_j > I_i$. Ở đây $\boldsymbol{\varepsilon}_i^{(t)}$ là nhiễu (thường lấy từ $\mathcal{U}[-\tfrac12,\tfrac12]^d$), và $\alpha$ là hệ số randomization. Nếu không có cá thể sáng hơn, nghiệm chủ yếu chịu nhiễu thăm dò.

\paragraph{Xử lý biên.}


Sau cập nhật, sử dụng \textbf{chiếu (clipping)} về miền hợp lệ $[\text{lower\_bound}, \text{upper\_bound}]$ 
cho từng chiều.

\subsubsection{Mô hình rời rạc cho Knapsack 0/1\cite{tilahun2017fireflyDiscrete}}

Biểu diễn nghiệm bằng $\mathbf{b}_i^{(t)} \in \{0,1\}^n$. Quy tắc di chuyển:

\textbf{(a) Di chuyển có hướng (Directed movement).}

Với mỗi đom đóm $j$ sáng hơn $i$:
\begin{enumerate}
    \item Xác định tập vị trí khác biệt: $D = \{k \mid b_{i,k} \neq b_{j,k}\}$.
    \item Chọn ngẫu nhiên **TỐI ĐA** $m_{\max}$ vị trí từ $D$.
    \item Lật bit tại các vị trí được chọn để $b_{i,k} \gets b_{j,k}$.
\end{enumerate}

\textbf{(b) Nhiễu ngẫu nhiên.}

Với xác suất $\alpha_{\text{flip}}$, chọn ngẫu nhiên một vị trí và lật bit:
\[
b_{i,k} \gets 1 - b_{i,k}.
\]

\textbf{(c) Sửa nghiệm vi phạm (Repair vs Penalty).}

Benchmark hỗ trợ hai chiến lược xử lý ràng buộc:
\begin{itemize}
    \item \textbf{Repair strategy}: Sau khi di chuyển, nếu nghiệm vi phạm ràng buộc sức chứa, loại dần các vật phẩm có tỷ số $v_k/w_k$ thấp nhất (greedy removal) cho đến khi khả thi.
    \item \textbf{Penalty strategy}: Nghiệm vi phạm nhận penalty lớn trong fitness, cho phép exploration trong không gian infeasible.
\end{itemize}

\paragraph{Gợi ý lựa chọn tham số.}
$\beta_0$ lớn $\Rightarrow$ khai thác cục bộ mạnh; $\gamma$ nhỏ $\Rightarrow$ hút tầm xa tăng thăm dò; $\alpha$ nên trong khoảng $[0.1, 0.5]$ để cân bằng exploration/exploitation. Kích thước quần thể $N$ đủ để bao phủ không gian ban đầu, thường $N \in [20,100]$ tuỳ độ khó/hàm mục tiêu (Yang, 2009; Yang, 2010).

% \subsection*{Tài liệu tham khảo (APA)}
% \begin{enumerate}
%     \item Baykasoğlu, A., Ozsoydan, F. B., \& Subulan, K. (2014). An improved firefly algorithm for solving dynamic multidimensional knapsack problems. \textit{Expert Systems with Applications, 41}(8), 3712--3725.
%     \item Yang, X.-S. (2009). Firefly algorithms for multimodal optimization. In O. Watanabe \& T. Zeugmann (Eds.), \textit{Stochastic Algorithms: Foundations and Applications} (SAGA 2009) (pp.~169--178). Springer.
%     \item Yang, X.-S. (2010). \textit{Nature-Inspired Metaheuristic Algorithms} (2nd ed.). Luniver Press.
%     \item Yang, X.-S., \& He, X. (2013). Firefly algorithm: Recent advances and applications. \textit{arXiv preprint} arXiv:1308.3898.
% \end{enumerate}

\subsection{Chi tiết triển khai thuật toán (Mã giả)}

\begin{algorithm}[H]
\caption{Thuật toán Đom Đóm cho tối ưu liên tục}
\begin{algorithmic}[1]
\STATE \textbf{Input:} Hàm $f$, miền $[\text{lb}, \text{ub}]^d$, $n$ đom đóm, $T$ vòng lặp, $\alpha, \beta_0, \gamma$.
\STATE Khởi tạo ngẫu nhiên $\{\mathbf{x}_i\}_{i=1}^n$ trong miền hợp lệ.
\STATE Tính fitness $f(\mathbf{x}_i)$ và độ sáng $I_i = -f(\mathbf{x}_i)$.
\FOR{$t = 1$ \TO $T$}
    \STATE Tính ma trận khoảng cách $r_{ij} = \|\mathbf{x}_i - \mathbf{x}_j\|_2$.
    \FOR{$i = 1$ \TO $n$}
        \FOR{$j = 1$ \TO $n$}
            \IF{$I_j > I_i$}
                \STATE $\beta := \beta_0 \exp(-\gamma r_{ij}^2)$
                \STATE $\mathbf{x}_i := \mathbf{x}_i + \beta (\mathbf{x}_j - \mathbf{x}_i) + \alpha \boldsymbol{\varepsilon}$
            \ENDIF
        \ENDFOR
        \STATE Chiếu $\mathbf{x}_i$ về $[\text{lb}, \text{ub}]^d$, cập nhật $f(\mathbf{x}_i)$ và $I_i$.
    \ENDFOR
    \STATE Ghi nhận nghiệm tốt nhất $\mathbf{x}^\star$, $f^\star$.
\ENDFOR
\STATE \textbf{Output:} $\mathbf{x}^\star$, $f^\star$.
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\caption{Thuật toán Đom Đóm cho Knapsack 0/1}
\begin{algorithmic}[1]
\STATE \textbf{Input:} $\mathbf{v}, \mathbf{w}, C$, $n$ đom đóm, $T$ vòng lặp, $\alpha_{\text{flip}}$, $m_{\max}$, strategy $\in \{$repair, penalty$\}$.
\STATE Khởi tạo $n$ nghiệm nhị phân $\mathbf{b}_i \in \{0,1\}^m$.
\STATE Tính fitness $f(\mathbf{b}_i)$ và độ sáng $I_i$.
\FOR{$t = 1$ \TO $T$}
    \FOR{$i = 1$ \TO $n$}
        \FOR{$j = 1$ \TO $n$}
            \IF{$I_j > I_i$}
                \STATE $D \gets \{k \mid b_{i,k} \neq b_{j,k}\}$
                \STATE Chọn ngẫu nhiên TỐI ĐA $m_{\max}$ vị trí từ $D$
                \STATE Với mỗi vị trí được chọn: $b_{i,k} \gets b_{j,k}$
            \ENDIF
        \ENDFOR
        \IF{$\text{rand}() < \alpha_{\text{flip}}$}
            \STATE Chọn ngẫu nhiên vị trí $k$ và lật: $b_{i,k} \gets 1 - b_{i,k}$
        \ENDIF
        \IF{strategy == repair}
            \STATE $\mathbf{b}_i \gets$ GreedyRepair($\mathbf{b}_i$) \COMMENT{Loại items có $v/w$ thấp}
        \ELSE
            \STATE Áp dụng penalty nếu vi phạm capacity
        \ENDIF
        \STATE Cập nhật $f(\mathbf{b}_i)$, $I_i$.
    \ENDFOR
    \STATE Ghi nhận nghiệm tốt nhất $\mathbf{b}^\star$, $f^\star$.
\ENDFOR
\STATE \textbf{Output:} $\mathbf{b}^\star$, giá trị balo $= -f^\star$.
\end{algorithmic}
\end{algorithm}


