% sections/results.tex – Results and conclusion section

\section{Thiết lập và phân tích kết quả các bài toán đánh giá}
\subsection{ACO và PSO}

Hai thuật toán này được áp dụng trên bài toán rời rạc - TSP. Đối với thuật toán PSO, nó sẽ áp dụng tốt nhất trên bài toán liên tục, tuy nhiên vì đã có 2 thuật toán đảm nhận việc đó (ABC và CS) nên thuật toán PSO sẽ được áp dụng trên bài toán TSP để khám phá giới hạn của nó trong việc giải các bài toán khó.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Phân tích Bản đồ "Tiny" (10 đỉnh)}
\label{subsec:tiny}

%--- CHỖ ĐỂ ĐIỀN ẢNH "TINY" ---
\begin{figure}[H]
    \centering
    % Nhóm 1: So sánh
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/compare_iterator_tiny.png}
        \caption{So sánh vòng lặp (Tiny)}
        \label{fig:iter_tiny}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/compare_length_tiny.png}
        \caption{So sánh độ dài tour (Tiny)}
        \label{fig:len_tiny}
    \end{subfigure}
    
    \vspace{1em}
    
    % Nhóm 2: So sánh thời gian và ACO
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/compare_time_tiny.png}
        \caption{So sánh thời gian chạy (Tiny)}
        \label{fig:time_tiny}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/ACO_tiny.png}
        \caption{Hội tụ ACO (Tiny)}
        \label{fig:aco_tiny}
    \end{subfigure}
    
    \vspace{1em}
    
    % Nhóm 3: PSO
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/PSO_tiny.png}
        \caption{Hội tụ PSO (Tiny)}
        \label{fig:pso_tiny}
    \end{subfigure}
    
    \caption{Kết quả thử nghiệm trên bản đồ ``Tiny'' (10 đỉnh).}
    \label{fig:tiny_maps}
\end{figure}
%--- KẾT THÚC CHỖ ĐỂ ẢNH "TINY" ---

Dựa trên các biểu đồ \texttt{\_tiny.png} (Hình~\ref{fig:tiny_maps}):

\begin{itemize}
    \item \textbf{Về Chất lượng Giải pháp (Độ dài Tour tốt nhất):}
    Biểu đồ \texttt{compare\_length\_tiny.png} cho thấy cả ba thuật toán đều tìm được các giải pháp có chất lượng \textbf{gần như tương đương nhau}.
    ACO (màu xanh) và Genetic Algorithm (GA - màu xanh lá) tìm được độ dài tour tốt nhất, xấp xỉ 12.4.
    PSO (màu cam) cho kết quả kém hơn một chút, xấp xỉ 12.5.
    Với bài toán quá nhỏ, sự khác biệt này là không đáng kể.

    \item \textbf{Về Thời gian Chạy (Total Execution Time):}
    Đây là nơi có sự khác biệt rõ rệt nhất (biểu đồ \texttt{compare\_time\_tiny.png}).
    \textbf{PSO (cam) cực kỳ chậm} (khoảng 1.85 giây).
    ACO (xanh) và GA (xanh lá) \textbf{rất nhanh} (lần lượt khoảng 0.15 giây và 0.08 giây). GA là nhanh nhất.

    \item \textbf{Về Tốc độ Hội tụ (Số vòng lặp):}
    Biểu đồ \texttt{compare\_iterator\_tiny.png} cho thấy cả ba thuật toán đều hội tụ (tìm thấy giải pháp tốt nhất) \textbf{rất nhanh, chỉ trong khoảng 10-15 vòng lặp đầu tiên}.
\end{itemize}

\paragraph{Tóm tắt (Tiny):} Với bài toán 10 đỉnh, cả ba thuật toán đều tìm ra giải pháp tốt gần như nhau. Tuy nhiên, PSO tốn thời gian tính toán \textit{lớn hơn hàng chục lần} so với ACO và GA.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Phân tích Bản đồ "Small" (30 đỉnh)}
\label{subsec:small}

%--- CHỖ ĐỂ ĐIỀN ẢNH "SMALL" ---
\begin{figure}[H]
    \centering
    % Nhóm 1: So sánh
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/compare_iterator_small.png}
        \caption{So sánh vòng lặp (Small)}
        \label{fig:iter_small}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/compare_length_small.png}
        \caption{So sánh độ dài tour (Small)}
        \label{fig:len_small}
    \end{subfigure}
    
    \vspace{1em}
    
    % Nhóm 2: So sánh thời gian và ACO
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/compare_time_small.png}
        \caption{So sánh thời gian chạy (Small)}
        \label{fig:time_small}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/ACO_small.png}
        \caption{Hội tụ ACO (Small)}
        \label{fig:aco_small}
    \end{subfigure}
    
    \vspace{1em}
    
    % Nhóm 3: PSO
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/PSO_small.png}
        \caption{Hội tụ PSO (Small)}
        \label{fig:pso_small}
    \end{subfigure}
    
    \caption{Kết quả thử nghiệm trên bản đồ ``Small'' (30 đỉnh).}
    \label{fig:small_maps}
\end{figure}
%--- KẾT THÚC CHỖ ĐỂ ẢNH "SMALL" ---

Dựa trên các biểu đồ \texttt{\_small.png} (Hình~\ref{fig:small_maps}):


\begin{itemize}
    \item \textbf{Về Chất lượng Giải pháp (Độ dài Tour tốt nhất):}
    Khi bài toán phức tạp hơn, sự khác biệt bắt đầu xuất hiện (biểu đồ \texttt{compare\_length\_small.png}).
    GA (xanh lá) tìm được giải pháp tốt nhất (ngắn nhất), khoảng 62.5.
    ACO (xanh) đứng thứ hai, rất sát sao, khoảng 63.0.
    PSO (cam) cho kết quả \textbf{tệ nhất} (dài nhất), khoảng 64.0.

    \item \textbf{Về Thời gian Chạy (Total Execution Time):}
    Xu hướng từ bản đồ "tiny" trở nên cực kỳ rõ rệt (biểu đồ \texttt{compare\_time\_small.png}).
    \textbf{PSO (cam) tốn thời gian một cách báo động} (gần 90 giây).
    ACO (xanh) và GA (xanh lá) vẫn duy trì hiệu quả, \textbf{rất nhanh} (lần lượt khoảng 1.5 giây và 2.0 giây). Lần này, ACO là nhanh nhất.

    \item \textbf{Về Tốc độ Hội tụ (Số vòng lặp):}
    Biểu đồ \texttt{compare\_iterator\_small.png} cho thấy:
    ACO (xanh) cần nhiều vòng lặp nhất để hội tụ hoàn toàn (khoảng 75-80 vòng lặp) nhưng liên tục cải thiện để đạt kết quả tốt.
    PSO (cam) và GA (đỏ) dường như hội tụ (ngừng cải thiện) nhanh hơn (khoảng 40-50 vòng lặp), nhưng lại bị kẹt ở các giải pháp kém chất lượng hơn.
\end{itemize}

\paragraph{Tóm tắt (Small):} Khi bài toán lớn lên 30 đỉnh, PSO bộc lộ rõ điểm yếu kép: vừa cho \textbf{kết quả tệ nhất} vừa tốn \textbf{thời gian chạy lâu nhất} (gấp $\sim$45 lần GA và $\sim$60 lần ACO). ACO và GA vẫn rất hiệu quả.


\subsubsection{Phân tích Bản đồ "Medium" (50 đỉnh)}
\label{subsec:medium}

%--- CHỖ ĐỂ ĐIỀN ẢNH "MEDIUM" ---
\begin{figure}[H]
    \centering
    % Nhóm 1: So sánh
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/compare_iterator_medium.png}
        \caption{So sánh vòng lặp (Medium)}
        \label{fig:iter_medium}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/compare_length_medium.png}
        \caption{So sánh độ dài tour (Medium)}
        \label{fig:len_medium}
    \end{subfigure}
    
    \vspace{1em}
    
    % Nhóm 2: So sánh thời gian và ACO
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/compare_time_medium.png}
        \caption{So sánh thời gian chạy (Medium)}
        \label{fig:time_medium}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/ACO_medium.png}
        \caption{Hội tụ ACO (Medium)}
        \label{fig:aco_medium}
    \end{subfigure}
    
    \vspace{1em}
    
    % Nhóm 3: PSO
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{picture/PSO_medium.png}
        \caption{Hội tụ PSO (Medium)}
        \label{fig:pso_medium}
    \end{subfigure}
    
    \caption{Kết quả thử nghiệm trên bản đồ ``Medium'' (50 đỉnh).}
    \label{fig:medium_maps}
\end{figure}
%--- KẾT THÚC CHỖ ĐỂ ẢNH "MEDIUM" ---

Dựa trên các biểu đồ \texttt{\_medium.png} (Hình~\ref{fig:medium_maps}):

\begin{itemize}
    \item \textbf{Về Chất lượng Giải pháp (Độ dài Tour tốt nhất):}
    Đối với bài toán rất phức tạp với số đỉnh lớn, sự khác biệt càng được lộ rõ (biểu đồ \texttt{compare\_length\_medium.png}).
    ACO và GA tìm được giải pháp tốt nhất (ngắn nhất) khá sát nhau, khoảng 6.0.
    PSO (cam) cho kết quả \textbf{tệ nhất}, khoảng 8.3.

    \item \textbf{Về Thời gian Chạy (Total Execution Time):}
    \textbf{PSO (cam)} tiếp tục ngốn quá nhiều thời gian.
    ACO (xanh) và GA (xanh lá) vẫn duy trì hiệu quả, tuy nhiên đã có sự vượt trội từ ACO.

    \item \textbf{Về Tốc độ Hội tụ (Số vòng lặp):}
    ACO (xanh) cần nhiều vòng lặp nhất để hội tụ hoàn toàn nhưng liên tục cải thiện để đạt kết quả tốt.
    PSO (cam) và GA (đỏ) hội tụ nhanh hơn (theo số vòng lặp) nhưng bị kẹt và không thể tìm ra giải pháp tốt nhất.
\end{itemize}

\paragraph{Tóm tắt (Medium):} Khi bài toán lớn lên 50 đỉnh, kết quả càng phân hóa rõ rệt. ACO tiếp tục thể hiện sự áp đảo, còn PSO trở nên càng tệ và chứng tỏ sự thiếu phù hợp.


\subsection{ABC}
Sau nhiều lần thử với nhiều loại bài toán khác nhau, ta thấy thuật toán ABC có độ ổn định cao, performance tốt với cả những hàm số đa cực trị hay có cực trị đặc biệt
\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{picture/ras_1.png}
        \caption{Sau lần 10}
    \end{minipage}
    \begin{minipage}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{picture/ras_2.png}
        \caption{Sau lần 30}
    \end{minipage}
    \begin{minipage}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{picture/ras_3.png}
        \caption{Kết quả}
    \end{minipage}
\end{figure}

So sánh với các thuật giải truyền thống: như đã nói ở trên, thuật toán ABC có performance cao, giải quyết tốt những bài toán mà các thuật toán truyền thống không giải được, chẳng hạn như hàm rastrigin:
\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{picture/ras_compare.png}
    \label{fig:placeholder1}
\end{figure}
\newpage
Tuy nhiên ABC cũng có điểm hạn chế, đó là tốc độ chậm hơn đáng kể so với các thuật toán truyền thống như hill climbing hay stimulated annealing, đặc biệt là trong một số bài toán không quá phức tạp, chẳng hạn như hàm circle (nửa dưới hình cầu):

\begin{figure}[h]
    \centering
    \includegraphics[width=0.25\linewidth]{picture/cir_compare.png}
    \label{fig:placeholder2}
\end{figure}

Ngoài ra, bộ nhớ sử dụng trong thuật toán ABC cũng nhiều hơn, tỉ lệ thuận với số lượng "con ong" được sử dụng.

\subsection{Firefly Algorithm}

\subsubsection{Thuật toán dùng để so sánh}

Để đặt Thuật toán Đom Đóm (FA) vào bối cảnh hợp lý, chúng tôi so sánh với ba thuật toán metaheuristic cổ điển: Hill Climbing (HC), Simulated Annealing (SA) và Genetic Algorithm (GA).  
Toàn bộ thuật toán được hiện thực trong cùng một khung mã Python, dùng chung: (i) giao diện bài toán, (ii) cơ chế sinh nghiệm khởi tạo, (iii) chuẩn hoá cách ghi log (history, số đánh giá, trạng thái run, \dots) và (iv) pipeline phân tích/visualize dùng chung cho cả Rastrigin và Knapsack.

\begin{description}[leftmargin=1.8em, labelsep=0.6em, style=nextline]

    \item[\textbf{Hill Climbing (HC).}]
    HC là baseline tham lam địa phương: luôn giữ một nghiệm hiện tại, sinh lân cận và chỉ chấp nhận nghiệm tốt hơn; khi không cải thiện sau một số vòng lặp thì restart.
    \begin{itemize}[leftmargin=1.8em, topsep=2pt]
        \item \textbf{Rastrigin (liên tục):} nghiệm được mã hoá dưới dạng vector thực; lân cận sinh bằng perturbation ngẫu nhiên trên từng chiều (Gaussian/Uniform tuỳ cấu hình). Mỗi vòng lặp đánh giá một tập lân cận có kích thước cố định và chọn best improvement; số vòng lặp hiệu dụng được suy ra từ budget và số lân cận mỗi vòng.
        \item \textbf{Knapsack (0/1):} nghiệm là vector nhị phân; lân cận sinh bằng bit-flip trên một số vị trí; khi bị kẹt lâu trên plateau (không cải thiện trong một số vòng) thì restart. Hàm mục tiêu dùng cùng quy ước với các thuật toán khác (tối đa hoá giá trị, đồng thời kiểm tra ràng buộc).
    \end{itemize}

    \item[\textbf{Simulated Annealing (SA).}]
    SA dùng cùng cấu trúc lân cận với HC, nhưng cho phép chấp nhận nghiệm xấu hơn với xác suất
    \[
        \mathbb{P}(\text{chấp nhận}) = \exp\!\left(-\frac{\Delta f}{T}\right),
    \]
    trong đó $T$ là nhiệt độ, giảm dần theo lịch làm nguội hình học
    $T_{k+1} = \text{cooling\_rate} \cdot T_k$ cho tới khi chạm $T_{\min}$.
    \begin{itemize}[leftmargin=1.8em, topsep=2pt]
        \item \textbf{Rastrigin (liên tục):} dùng cùng kiểu perturbation như HC để đảm bảo so sánh công bằng; nhiệt độ khởi tạo $T_0$ tương đối cao, hệ số làm nguội gần 1, và $T_{\min}$ cố định cho mọi cấu hình.
        \item \textbf{Knapsack (0/1):} vẫn dùng lân cận bit-flip; chỉ điều chỉnh $T_0$ và \texttt{cooling\_rate}. Mỗi bước đánh giá đúng một nghiệm mới, nên số vòng lặp bằng budget.
    \end{itemize}

    \item[\textbf{Genetic Algorithm (GA).}]
    GA duy trì một quần thể cá thể và lặp lại chu trình: chọn lọc (tournament selection), lai ghép (crossover) và đột biến (mutation), kèm một mức elitism để giữ lại các cá thể tốt nhất qua thế hệ.
    \begin{itemize}[leftmargin=1.8em, topsep=2pt]
        \item \textbf{Rastrigin (liên tục):} cá thể là vector thực chiều $d$; crossover và mutation được thiết kế cho không gian liên tục, với tỉ lệ crossover/mutation và kích thước quần thể \texttt{pop\_size} được cố định theo từng cấu hình Rastrigin trong \texttt{config.py}. Budget tổng được phân bổ thành $\text{max\_iter} \times \text{pop\_size}$ lượt đánh giá.
        \item \textbf{Knapsack (0/1):} cá thể là vector nhị phân; crossover và mutation đều thao tác trên bit; \texttt{pop\_size} tăng theo kích thước bài toán (lớn hơn cho $n=200$ so với $n=50,100$). Trong mọi trường hợp luôn bật elitism và sử dụng tournament selection với kích thước giải đấu cố định.
    \end{itemize}

    \item[\textbf{Firefly Algorithm (FA).}]
    FA mô phỏng bầy đom đóm trong đó mỗi nghiệm là một cá thể phát sáng; cá thể kém sáng di chuyển về phía cá thể sáng hơn với cường độ phụ thuộc khoảng cách và tham số hấp dẫn $\beta_0$, trong khi thành phần nhiễu có biên độ $\alpha$ giúp duy trì khả năng khám phá.
    \begin{itemize}[leftmargin=1.8em, topsep=2pt]
        \item \textbf{Rastrigin (liên tục):} FA được dùng dưới dạng chuẩn trong không gian liên tục: vị trí đom đóm là vector thực, khoảng cách được tính trong không gian Euclid, và chuyển động kết hợp giữa thành phần hút (về các nghiệm tốt hơn) và nhiễu ngẫu nhiên. Ba cấu hình Rastrigin trong \texttt{config.py}—\texttt{quick\_convergence} ($d=10$), \texttt{multimodal\_escape} ($d=30$) và \texttt{scalability} ($d=50$)—mỗi cấu hình có một bộ tham số FA riêng (số đom đóm, $\alpha$, $\beta_0$, $\gamma$). Khi dimension tăng, \texttt{n\_fireflies} và budget tăng để bù lại độ khó; $\alpha$ được giữ trong khoảng vừa đủ để tránh hội tụ quá sớm; $\gamma$ giảm dần theo $d$ nhằm tránh việc lực hút bị triệt tiêu quá nhanh do khoảng cách tăng theo $\sqrt{d}$.
        \item \textbf{Knapsack (0/1):}\cite{pisinger2005hard} dùng biến thể FA đã rời rạc hoá, đúng với cấu hình trong \texttt{config.py} và \texttt{instance\_generator.py}: mỗi đom đóm là một vector nhị phân chiều $n$; chuyển động có hướng lật tối đa \texttt{max\_flips\_per\_move} $=3$ bit để tiến gần cá thể sáng hơn; ngoài ra mỗi bit còn có xác suất bị lật do nhiễu $\alpha_{\text{flip}} = 0{,}2$ để duy trì đa dạng. Ràng buộc sức chứa được xử lý bằng chiến lược repair \texttt{greedy\_remove} (loại dần các vật phẩm có tỉ lệ $v_k/w_k$ thấp nhất) để đưa nghiệm về trạng thái feasible; cơ chế penalty vẫn được hỗ trợ trong code nhưng không được dùng trong benchmark chính. Số đom đóm \texttt{n\_fireflies} tăng theo kích thước bài toán: với $n \le 100$ dùng $30$ đom đóm, với $n=200$ dùng $40$; budget tổng tương ứng là $5000$ và $10000$ lần đánh giá, phân bổ thành $\text{max\_iter} \times \text{n\_fireflies}$.
    \end{itemize}

\end{description}


\paragraph{Lưu ý về tham số.}
Các tham số \emph{không} dùng chung cho toàn bộ lớp bài toán, mà được cố định \textbf{theo từng kịch bản benchmark}:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Rastrigin:} mỗi cấu hình \texttt{quick\_convergence} (10D), \texttt{multimodal\_escape} (30D), \texttt{scalability} (50D) có một \emph{RastriginConfig} riêng trong \texttt{config.py}, chứa: dimension, budget, ngưỡng gold/silver/bronze và bộ tham số FA, SA, HC, GA tương ứng. Các tham số này được cố định cho toàn bộ 30 lần chạy (30 seeds) và không tune theo từng instance.
    \item \textbf{Knapsack:} \texttt{get\_knapsack\_configs()} sinh các cấu hình cho $n \in \{50,100,200\}$, mỗi cấu hình gắn với một loại instance (uncorrelated, weakly, strongly, inverse) và một instance\_seed $\in \{42,123,999\}$. Trong mỗi cấu hình, budget, \texttt{n\_fireflies} và \texttt{pop\_size} được scale theo $n$ như đã nêu; các tham số này cố định cho toàn bộ 30 lần chạy metaheuristic trên cùng một instance.
\end{itemize}

\vspace{0.5em}
\subsubsection{Bài toán đánh giá}

\paragraph{Hàm Rastrigin (liên tục).}
Hàm Rastrigin là một hàm kiểm thử kinh điển trong tối ưu hoá toàn cục: phi lồi, đa cực trị mạnh, với rất nhiều cực tiểu địa phương phân bố đều trong không gian nghiệm, và một cực tiểu toàn cục tại $\mathbf{0}$ với $f(\mathbf{0})=0$. Hàm chuẩn được định nghĩa trên miền $[-5{,}12, 5{,}12]^d$
\[
    f(\mathbf{x}) = 10d + \sum_{i=1}^d \left( x_i^2 - 10\cos(2\pi x_i) \right).
\]

Trong benchmark này, chúng tôi sử dụng ba cấu hình được định nghĩa tường minh trong \texttt{RASTRIGIN\_CONFIGS}:
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{\texttt{quick\_convergence}:} $d = 10$, budget $10^4$ đánh giá; mục tiêu là quan sát tốc độ hội tụ sớm của các thuật toán trên một phiên bản tương đối dễ.
    \item \textbf{\texttt{multimodal\_escape}:} $d = 30$, budget $3 \times 10^4$; nhấn mạnh khả năng thoát bẫy cục bộ khi không gian nghiệm mở rộng và số lượng cực tiểu địa phương tăng.
    \item \textbf{\texttt{scalability}:} $d = 50$, budget $5 \times 10^4$; đây là cấu hình khó nhất, dùng để kiểm tra xu hướng suy giảm hiệu năng khi tăng dimension trong điều kiện budget hữu hạn.
\end{itemize}
Mỗi cấu hình đi kèm một bộ ngưỡng chất lượng (gold/silver/bronze) riêng cho sai số so với optimum; các ngưỡng này được đặt nới lỏng dần khi dimension tăng và được sử dụng nhất quán trong toàn bộ pipeline phân tích.

\paragraph{Bài toán Knapsack 0/1 (rời rạc).}\cite{smithmiles2021revisiting}
Bài toán Knapsack 0/1 được mô hình hoá dưới dạng tối ưu hoá tổ hợp: cho trước $n$ vật phẩm với trọng lượng $w_k$ và giá trị $v_k$, cùng sức chứa $C$, tìm tập con các vật phẩm sao cho tổng trọng lượng không vượt quá $C$ và tổng giá trị là lớn nhất.

Các instance được sinh bằng \texttt{generate\_knapsack\_instance()} trong \texttt{instance\_generator.py} với bốn kiểu phân phối giá trị–trọng lượng chuẩn trong literature:
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{uncorrelated:} $v_k$ và $w_k$ độc lập, đều phân bố đều trên cùng một khoảng; không có cấu trúc tương quan rõ rệt.
    \item \textbf{weakly correlated:} $w_k$ được sinh trước, $v_k \approx w_k$ cộng thêm nhiễu nhỏ; tạo ra tương quan dương yếu.
    \item \textbf{strongly correlated:} $v_k = w_k + \text{const}$; tương quan dương mạnh, cấu trúc gần với trường hợp “giá trị tỷ lệ với trọng lượng”.
    \item \textbf{inverse:} $v_k$ giảm khi $w_k$ tăng (dựa trên $w_{\max}$); tạo ra tương quan âm, thường được xem là khó hơn với các heuristic tham lam. 
\end{itemize}
Sức chứa $C$ được đặt bằng một tỉ lệ cố định của tổng trọng lượng (capacity\_ratio trong code).

\textbf{Cấu hình benchmark.}\cite{dolan2002benchmarking,more2009benchmarking}
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Kích thước:} $n \in \{50, 100, 200\}$.
    \item \textbf{Instance:} với mỗi cặp $(n,\text{instance\_type})$, sinh 3 instance độc lập với \texttt{instance\_seed} $\in \{42,123,999\}$.
    \item \textbf{Budget:} nếu $n \le 100$ thì budget là $5000$ lần đánh giá; nếu $n=200$ thì budget là $10000$. Budget này được chuyển thành số vòng lặp cho từng thuật toán dựa trên kích thước quần thể/tập lân cận.
    \item \textbf{Nghiệm tối ưu:} với mọi instance có $n \le 200$, nghiệm tối ưu $z^\star$ được tính bằng Dynamic Programming (DP) trong \texttt{run\_knapsack.py} và được lưu lại trong metadata; đây là chuẩn cho mọi tính toán optimality gap.
    \item \textbf{Số lần chạy metaheuristic:} trên mỗi instance, mỗi thuật toán được chạy $30$ lần với seed khác nhau (seed $\in \{0,\dots,29\}$), đúng như danh sách \texttt{seeds} trong code.
\end{itemize}

\vspace{0.5em}
\subsubsection{Chỉ số đánh giá}
\label{subsec:Chi_so_danh_gia}
\paragraph{Rastrigin.}
Rastrigin được xem như bài toán minimization với nghiệm tối ưu toàn cục $f^\star = 0$. Trên tập kết quả thu được, chúng tôi sử dụng các chỉ số sau, bám sát chuẩn COCO/BBOB và các công trình về benchmarking tối ưu hoá:
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{ECDF fixed-target:} hàm phân phối thực nghiệm của runtime (số đánh giá hàm) để đạt các mức sai số mục tiêu (gold/silver/bronze). Mỗi điểm trên đường cong biểu diễn tỉ lệ run đã đạt target trong không quá $N$ đánh giá.
    \item \textbf{Fixed-budget summary:} sai số cuối cùng tại một số mốc budget chuẩn hoá (ví dụ 10\%, 25\%, 50\%, 75\%, 100\% budget) được dùng để so sánh chất lượng nghiệm khi tài nguyên bị giới hạn.
    \item \textbf{ERT (Expected Running Time):} số lần đánh giá kỳ vọng để đạt một target nhất định. ERT được tính trên cả các run thành công và thất bại bằng công thức chuẩn trong literature: runtime của run thất bại được thay bằng budget và đưa vào mẫu.
    \item \textbf{Performance profiles:} theo định nghĩa của Dolan–Moré, performance profile là hàm phân phối của tỉ lệ hiệu năng $\rho_{p,s}$ giữa thuật toán $s$ và thuật toán tốt nhất trên cùng bài toán $p$. Biểu đồ thể hiện xác suất một thuật toán có $\rho_{p,s} \le \tau$ khi quét qua các problem.
    \item \textbf{Data profiles:} theo Moré–Wild, data profile đo tỉ lệ problem được giải tới một mức chất lượng cho trước trong budget chuẩn hoá $\nu$ (số đánh giá trên mỗi biến). Đây là góc nhìn “theo budget” bổ sung cho performance profile.
\end{itemize}
Mọi chỉ số runtime phía trên đều được tính dựa trên số đánh giá hàm (function evaluations), không dùng thời gian thực, để giảm nhiễu do khác biệt phần cứng.

\paragraph{Knapsack.}
Đối với Knapsack 0/1, chúng tôi khai thác việc có nghiệm tối ưu $z^\star$ từ DP để xây dựng các chỉ số dựa trên \emph{optimality gap}:
\[
    \text{gap} = \frac{z^\star - z_{\text{alg}}}{z^\star} \times 100\%,
\]
với $z_{\text{alg}}$ là giá trị nghiệm tốt nhất của thuật toán.

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Các tier chất lượng:} sử dụng ba ngưỡng
    \[
        1\%,\quad 5\%,\quad 10\%
    \]
    tương ứng với gold, silver, bronze, trùng với \texttt{KNAPSACK\_GAP\_THRESHOLDS} trong \texttt{config.py}. Các tier này được dùng vừa để đánh nhãn chất lượng nghiệm cuối cùng, vừa làm target cho các phân tích runtime.
    \item \textbf{Tỉ lệ thành công theo tier:} trên mỗi cấu hình $(n, \text{instance\_type})$, tính tỉ lệ run đạt gap $\le$ ngưỡng tương ứng trong budget cho phép.
    \item \textbf{Feasibility rate:} tỉ lệ nghiệm cuối cùng thoả ràng buộc sức chứa. Chỉ số này đặc biệt quan trọng khi so sánh các chiến lược xử lý ràng buộc (repair so với penalty).
    \item \textbf{Runtime và profile:} tương tự Rastrigin, chúng tôi xây dựng ECDF fixed-target, ERT, performance profiles và data profiles, nhưng target ở đây là các ngưỡng gap (1\%, 5\%, 10\%). Để đảm bảo ý nghĩa, các phân tích này chỉ sử dụng các instance có \texttt{has\_dp\_optimal} = True trong metadata.
\end{itemize}

Toàn bộ chỉ số trên được trích xuất tự động bởi \texttt{analyze\_results.py} dựa trên các JSON kết quả từ \texttt{run\_rastrigin.py} và \texttt{run\_knapsack.py}, sau đó được sử dụng bởi \texttt{visualize.py} để tạo các biểu đồ phục vụ đánh giá định tính và định lượng.


\vspace{0.5em}

\subsubsection{Rastrigin: mức độ tiệm cận nghiệm tối ưu và đặc trưng hội tụ}

\paragraph{ECDF theo ngưỡng mục tiêu.}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ecdf_quick_convergence.png}
\caption{ECDF cho quick\_convergence (dim=10).}
\label{fig:rastrigin_ecdf_quick}
\end{figure}

Đối với cấu hình 10 chiều, ECDF cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item Ở mức Bronze, cả FA và GA đều đạt tỉ lệ thành công rất cao: các đường ECDF tiệm cận 1 khi ngân sách tiến dần tới khoảng \(10^3\) lần đánh giá. FA có xu hướng đạt cùng mức ECDF với chi phí nhỏ hơn đôi chút, thể hiện lợi thế nhẹ về tốc độ hội tụ.
    \item HC chậm hơn rõ rệt: đường ECDF nằm thấp và tăng chậm, phản ánh việc thuật toán này thường bị kẹt trong các cực trị địa phương của Rastrigin ngay cả với ngưỡng Bronze.
    \item Ở mức Silver, sự khác biệt trở nên rõ ràng: chỉ FA (đặc biệt là cấu hình \emph{specialist}) duy trì được ECDF đáng kể (xấp xỉ \(0.6\)–\(0.7\)), trong khi GA và HC hầu như không chạm được ngưỡng trong ngân sách đang xét, các đường ECDF gần như bám sát trục hoành. FA vì vậy là thuật toán duy nhất còn hoạt động hiệu quả khi yêu cầu độ chính xác cao hơn trên Rastrigin 10 chiều.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ecdf_multimodal_escape.png}
\caption{ECDF cho multimodal\_escape (dim=30).}
\label{fig:rastrigin_ecdf_multimodal}
\end{figure}

Khi tăng lên 30 chiều, hình dạng ECDF cho thấy độ khó tăng rõ rệt:

\begin{itemize}[leftmargin=1.6em]
    \item Ở mức Bronze, chỉ còn các biến thể của FA (bản gốc và \emph{specialist}) đạt được tỉ lệ thành công đáng kể. Cả hai đường cong đều bị dịch sang phải, cần tới cỡ \(10^4\) đánh giá để ECDF tiệm cận 1; cấu hình \emph{specialist} đạt cùng mức ECDF với chi phí thấp hơn, cho thấy việc tinh chỉnh tham số giúp cải thiện rõ rệt khả năng thoát bẫy đa cực trị.
    \item Các thuật toán còn lại (GA, HC, SA) hầu như không đạt được ngưỡng Bronze trong ngân sách đã chọn nên không xuất hiện trên đồ thị; về thực chất, chúng thất bại gần như hoàn toàn trên Rastrigin 30 chiều ở mức mục tiêu này.
    \item Ở mức Silver, độ khó tăng vọt: chỉ FA \emph{specialist} đạt được một phần nhỏ số lần chạy (ECDF dừng dưới \(0.3\) ngay cả ở rìa phải trục hoành), trong khi FA gốc và các thuật toán khác không có lần chạy nào chạm ngưỡng. Điều này cho thấy từ 30 chiều trở lên, mức Silver của Rastrigin đã vượt quá khả năng của hầu hết thuật toán trong bộ benchmark.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ecdf_scalability.png}
\caption{ECDF cho scalability (dim=50, trục log).}
\label{fig:rastrigin_ecdf_scale}
\end{figure}

Ở cấu hình 50 chiều, Rastrigin trở thành một bài toán đặc biệt thách thức trong bối cảnh ngân sách giới hạn:

\begin{itemize}[leftmargin=1.6em]
    \item Ở mức Bronze, chỉ còn FA \emph{specialist} đạt được một tỉ lệ thành công trung bình khá khiêm tốn: đường ECDF tăng rất chậm và chỉ tiệm cận quanh \(0.7\) khi ngân sách tiến gần \(4\times 10^4\) đánh giá. FA gốc và các thuật toán khác không đạt được ngưỡng nên không để lại dấu vết trên đồ thị.
    \item Ở mức Silver, toàn bộ các đường ECDF nằm tại 0, tương đương việc không thuật toán nào đạt được ngưỡng Silver trên Rastrigin 50 chiều trong ngân sách tối đa. Rastrigin high-dimensional với yêu cầu độ chính xác cao vì thế có thể xem là “ngoài tầm với” đối với tập thuật toán đang xét.
\end{itemize}

\paragraph{Fixed-Budget Performance: sai số cuối cùng dưới các mức ngân sách cố định.}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{picture/rastrigin_fixed_budget_quick_convergence.png}
\caption{Rastrigin – fixed-budget performance (quick\_convergence, $d=10$). Trục tung là sai số trung vị (median error), trục hoành là tỉ lệ ngân sách.}
\label{fig:rastrigin_budget_quick}
\end{figure}

Với cấu hình quick\_convergence (10 chiều), đường cong fixed-budget cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item Cả FA và GA đều có sai số trung vị giảm đơn điệu khi tăng ngân sách, nhưng FA luôn giữ mức sai số thấp hơn rõ rệt. Ở mọi mức budget (10\%, 30\%, 50\%, 100\%), đường của FA nằm dưới GA khoảng gần một bậc độ lớn trên thang log.
    \item Lợi ích của việc tăng ngân sách thể hiện mạnh giữa 10\% và 30\%; sau khoảng 50\% ngân sách, cả hai thuật toán đều rơi vào vùng “diminishing returns”, sai số giảm thêm rất ít.
    \item Cấu hình \emph{specialist} cải thiện nhẹ cho cả hai thuật toán, chủ yếu ở ngân sách nhỏ (10–30\%). Tuy nhiên, thứ hạng tương đối không đổi: FA vẫn là thuật toán cho sai số cuối cùng thấp nhất, GA ổn định nhưng kém hơn trên toàn dải ngân sách.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{picture/rastrigin_fixed_budget_multimodal_escape.png}
\caption{Rastrigin – fixed-budget performance (multimodal\_escape, $d=30$).}
\label{fig:rastrigin_budget_multimodal}
\end{figure}

Khi tăng lên cấu hình multimodal\_escape (30 chiều), độ khó tăng rõ rệt:

\begin{itemize}[leftmargin=1.6em]
    \item Mức sai số trung vị của cả FA và GA đều cao hơn đáng kể so với $d=10$, ngay cả ở 100\% ngân sách. Điều này phù hợp với ECDF: nhiều lần chạy không chạm được các target Silver dù đã dùng hết ngân sách.
    \item FA tiếp tục giữ lợi thế ổn định: ở mọi mức budget, đường cong của FA nằm thấp hơn GA, và khoảng cách giữa hai thuật toán vẫn tương đối lớn.
    \item Tinh chỉnh \emph{specialist} giúp FA giảm thêm vài đơn vị sai số trên toàn dải ngân sách, trong khi GA cũng cải thiện nhưng vẫn bị bỏ xa. Có thể hiểu rằng ở 30 chiều, FA không chỉ đạt tỉ lệ thành công cao hơn (ECDF) mà còn cho chất lượng nghiệm cuối cùng tốt hơn trong khung fixed-budget.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{picture/rastrigin_fixed_budget_scalability.png}
\caption{Rastrigin – fixed-budget performance (scalability, $d=50$).}
\label{fig:rastrigin_budget_scale}
\end{figure}

Ở cấu hình scalability (50 chiều), bức tranh trở nên bi quan hơn:

\begin{itemize}[leftmargin=1.6em]
    \item Các đường cong cho thấy sai số trung vị vẫn rất cao ngay cả khi dùng 100\% ngân sách: FA chỉ giảm từ khoảng $\sim 1.7\times 10^2$ xuống dưới $10^2$, GA dao động quanh vùng $[1.8, 3]\times 10^2$. Điều này nhất quán với ECDF: gần như không có lần chạy nào đạt được các target Bronze/Silver ở 50 chiều.
    \item FA tiếp tục vượt trội GA trên toàn bộ dải budget: với cùng một ngân sách, nghiệm trung vị của FA luôn tốt hơn đáng kể. Nói cách khác, nếu buộc phải chọn giữa hai thuật toán trong bối cảnh high-dimensional Rastrigin, FA luôn là lựa chọn “ít tệ hơn”.
    \item Cấu hình \emph{specialist} giúp FA cải thiện thêm một chút (đặc biệt ở ngân sách thấp), nhưng không thay đổi bản chất vấn đề: với dimension 50 và ngân sách hiện tại, cả hai thuật toán đều đang hoạt động trong vùng “chưa hội tụ”, sai số tuyệt đối vẫn lớn so với nghiệm tối ưu.
\end{itemize}


\paragraph{ERT, performance profiles và data profiles.}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ert_bronze.png}
\caption{Rastrigin – ERT tới ngưỡng Bronze.}
\label{fig:rastrigin_ert_bronze}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ert_silver.png}
\caption{Rastrigin – ERT tới ngưỡng Silver.}
\label{fig:rastrigin_ert_silver}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ert_gold.png}
\caption{Rastrigin – ERT tới ngưỡng Gold (không có thuật toán nào đạt target).}
\label{fig:rastrigin_ert_gold}
\end{figure}

ERT (Expected Running Time) chỉ có ý nghĩa khi tồn tại số lượng đủ lớn các lần chạy thành công trên target đang xét. Các biểu đồ ERT cho Rastrigin cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Ngưỡng Bronze.} Ở cấu hình \emph{quick\_convergence} (10 chiều), cả FA, GA và HC đều đạt được target Bronze. FA có ERT nhỏ nhất (cỡ $10^2$–$10^3$ đánh giá), GA chậm hơn khoảng một bậc, còn HC chậm hơn rất nhiều bậc và do đó chỉ đóng vai trò baseline. SA hầu như không đạt được target. Ở hai cấu hình khó hơn (\emph{multimodal\_escape} 30 chiều và \emph{scalability} 50 chiều), chỉ có FA đạt Bronze; các thuật toán còn lại không có run thành công nên không xuất hiện trên biểu đồ. Việc tinh chỉnh (\emph{specialist}) giúp ERT của FA giảm đáng kể nhưng giá trị tuyệt đối vẫn nằm trong vùng từ vài chục nghìn tới hàng triệu đánh giá.
    \item \textbf{Ngưỡng Silver.} Với Silver, bức tranh càng khắt khe hơn. Ở 10 chiều, FA và GA vẫn đạt target nhưng ERT của GA lớn hơn FA khá rõ, phản ánh việc GA cần nhiều đánh giá hơn để hội tụ tới mức sai số sâu hơn. Ở 30 chiều, chỉ còn FA (đặc biệt là cấu hình \emph{specialist}) đạt Silver với ERT rất lớn (khoảng $10^5$ đánh giá), và ở 50 chiều chỉ FA \emph{specialist} đạt Silver với ERT lên tới cỡ $10^6$. Điều này nhất quán với ECDF: Silver trên Rastrigin high-dimensional là một target cực khó.
    \item \textbf{Ngưỡng Gold.} Trên cả ba cấu hình và bốn thuật toán, không có run nào đạt được target Gold trong ngân sách cho phép. Vì vậy Hình~\ref{fig:rastrigin_ert_gold} thực chất minh hoạ một trường hợp “ERT không xác định”: success rate bằng 0, và mọi so sánh ERT tại ngưỡng Gold đều vô nghĩa.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{picture/rastrigin_perf_profile.png}
\caption{Performance profiles cho Rastrigin (Dolan–Moré).}
\label{fig:rastrigin_perf_profile}
\end{figure}

Performance profile mô tả, với mỗi tỷ lệ hiệu năng $\tau$, tỷ lệ các bài toán mà một thuật toán có thời gian chạy không vượt quá $\tau$ lần solver tốt nhất. Kết quả cho Rastrigin cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item Đường cong của FA nằm cao hơn GA tại $\tau = 1$, tức là trong số rất ít các cặp (cấu hình, target) được giải thành công, FA thường là thuật toán nhanh nhất về số lần đánh giá.
    \item Khi tăng $\tau$ lên khoảng 3, đường của GA mới bắt kịp FA; hai đường đều tiệm cận một mức trần thấp (khoảng $0{,}1$), phản ánh thực tế là chỉ một phần rất nhỏ các bài toán trong bộ test được giải bởi bất kỳ thuật toán nào.
    \item HC và SA hầu như không xuất hiện trên performance profile vì không giải được target nào trong tập Rastrigin ở các mức ngân sách đã chọn.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{picture/rastrigin_data_profile.png}
\caption{Data profiles cho Rastrigin (Moré–Wild).}
\label{fig:rastrigin_data_profile}
\end{figure}

Data profile $\psi(\nu)$ biểu diễn tỷ lệ bài toán được giải trong một ngân sách chuẩn hoá $\nu$ cho trước. Trên Rastrigin:

\begin{itemize}[leftmargin=1.6em]
    \item FA luôn là thuật toán có coverage cao nhất: với ngân sách rất nhỏ (vài trăm đánh giá), FA đã giải được khoảng $1/6$ số bài toán; khi tăng ngân sách lên cỡ $10^4$–$3\times10^4$ đánh giá, coverage tăng dần lên gần $2/3$.
    \item GA chỉ bắt đầu giải được bài toán khi ngân sách tăng lên mức trung bình và nhanh chóng đạt trần quanh mức $1/3$ số bài toán; sau đó đường cong của GA hầu như phẳng, không hưởng lợi nhiều từ việc tăng ngân sách.
    \item HC và SA không giải được bất kỳ instance nào trong bộ target Rastrigin dưới các mức ngân sách đã xét, nên đường data profile gần như dính sát trục hoành.
    \item Ngay cả ở ngân sách lớn nhất, không có thuật toán nào đạt coverage gần 1; điều này củng cố nhận định rằng Rastrigin high-dimensional (đặc biệt với các target Silver/Gold) về cơ bản là quá khó trong khung ngân sách hiện tại.
\end{itemize}

\subsubsection{Rastrigin: đa dạng quần thể và hiện tượng dừng sớm (stagnation)}

\paragraph{Đa dạng quần thể theo thời gian.}

Đa dạng quần thể được đo bằng khoảng cách Euclid trung bình giữa các cá thể, chuẩn hoá theo \(\sqrt{D}\) để cho phép so sánh giữa các chiều khác nhau.  
Hình~\ref{fig:rastrigin_diversity_quick}–\ref{fig:rastrigin_diversity_scale} hiển thị boxplot của bốn thời điểm:
\emph{initial} (ngay sau khởi tạo), \emph{mid} (50\% ngân sách), \emph{final} (kết thúc chạy) và \emph{drop} (mức giảm đa dạng từ initial tới final).

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_diversity_quick_convergence.png}
\caption{Rastrigin – phân tích đa dạng quần thể (quick\_convergence, \(D=10\)).}
\label{fig:rastrigin_diversity_quick}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_diversity_multimodal_escape.png}
\caption{Rastrigin – phân tích đa dạng quần thể (multimodal\_escape, \(D=30\)).}
\label{fig:rastrigin_diversity_multimodal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_diversity_scalability.png}
\caption{Rastrigin – phân tích đa dạng quần thể (scalability, \(D=50\)).}
\label{fig:rastrigin_diversity_scale}
\end{figure}

Các quan sát chính:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Khởi tạo.}  
    Trên cả ba cấu hình, FA và GA đều bắt đầu với mức đa dạng khá cao (\(\approx 2{,}0\)–\(2{,}8\) sau chuẩn hoá).  
    Với cấu hình quick\_convergence, GA (đặc biệt bản out-of-the-box) có đa dạng khởi tạo lớn hơn FA, trong khi FA \emph{specialist} có mức cao nhất.  
    Điều này cho thấy lợi thế của FA trên Rastrigin không đến từ việc “rải quần thể rộng hơn ngay từ đầu” mà chủ yếu do động lực cập nhật trong quá trình tối ưu.
    
    \item \textbf{Giữa quá trình (50\% ngân sách).}  
    Ở cả ba cấu hình, GA mất đa dạng rất nhanh: median diversity của GA chỉ còn \(\approx 0{,}01\)–\(0{,}02\), trong khi FA vẫn duy trì quanh \(\approx 0{,}06\)–\(0{,}10\).  
    FA \emph{specialist} có đa dạng mid hơi thấp hơn FA gốc nhưng vẫn cao hơn GA rõ rệt.  
    Tức là GA trải qua hiện tượng \emph{premature convergence}: áp lực chọn lọc và lai ghép làm quần thể co cụm sớm quanh một vài basin, trong khi FA vẫn giữ được một “vòng đai” nghiệm khác biệt hơn.
    
    \item \textbf{Cuối quá trình.}  
    Tới thời điểm kết thúc, đa dạng của GA gần như bằng 0 ở mọi cấu hình, cho thấy quần thể gần như đồng nhất.  
    FA vẫn giữ một mức đa dạng dương đáng kể (đặc biệt ở multimodal\_escape và scalability), dù đã giảm hơn 90\% so với ban đầu.  
    Điều này phù hợp với quan sát ECDF: FA vẫn còn khả năng “nhúc nhích” sang các basin khác ở cuối run, trong khi GA gần như bị khoá cứng trong một vùng nghiệm.
    
    \item \textbf{Mức giảm đa dạng (drop).}  
    Cả FA và GA đều có \emph{drop} lớn (trên 90\% initial diversity), riêng GA thường tụt về gần 0 nên drop tuyệt đối của GA thường lớn hơn hoặc tương đương FA.  
    FA \emph{specialist} có drop lớn nhất trên quick\_convergence do khởi tạo rất rộng, nhưng vẫn duy trì đa dạng mid/final cao hơn GA – tức là FA tuned vừa mở rộng được phạm vi tìm kiếm ban đầu vừa không suy sụp quá nhanh.
    
    \item \textbf{HC và SA.}  
    HC và SA làm việc với một quỹ đạo đơn (population size = 1), nên chỉ số đa dạng về mặt định nghĩa luôn bằng 0.  
    Việc hai thuật toán này thất bại trên Rastrigin high-dimensional vì vậy không liên quan tới “quản lý đa dạng” mà nằm ở cơ chế bước nhảy và tiêu chí chấp nhận (đã được phản ánh ở ECDF và ERT).
\end{itemize}

Tóm lại, trên các bài toán Rastrigin khó, FA không hề “giữ đa dạng tốt” theo nghĩa tuyệt đối – quần thể của nó cũng co cụm mạnh. Tuy nhiên, so với GA, FA duy trì được một mức lan trải vừa đủ ở giai đoạn giữa và cuối quá trình, đủ để sinh ra một số lời giải thoát khỏi bẫy địa phương. GA lại đánh mất đa dạng quá sớm, dẫn tới trạng thái tìm kiếm gần như gradient-free quanh một cực trị trung bình.

\paragraph{Phân tích stagnation.}

Để làm rõ hơn mối liên hệ giữa đa dạng và khả năng thoát bẫy, ta xem xét \emph{độ dài stagnation}: số thế hệ liên tiếp mà giá trị tốt nhất toàn cục không được cải thiện. Với mỗi run, ta lấy đoạn stagnation dài nhất.  
Hình~\ref{fig:rastrigin_stagnation_quick}–\ref{fig:rastrigin_stagnation_scale} trình bày phân bố độ dài này (histogram) và ECDF tương ứng cho FA và GA.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_stagnation_quick_convergence.png}
\caption{Rastrigin – phân tích stagnation (quick\_convergence, \(D=10\)).}
\label{fig:rastrigin_stagnation_quick}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_stagnation_multimodal_escape.png}
\caption{Rastrigin – phân tích stagnation (multimodal\_escape, \(D=30\)).}
\label{fig:rastrigin_stagnation_multimodal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_stagnation_scalability.png}
\caption{Rastrigin – phân tích stagnation (scalability, \(D=50\)).}
\label{fig:rastrigin_stagnation_scale}
\end{figure}

Các kết quả cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Quick\_convergence (10 chiều).}  
    Cả FA và GA đều có độ dài stagnation trung bình vào khoảng 100–160 thế hệ, phản ánh việc bài toán tương đối dễ: cả hai thuật toán vẫn tiếp tục tạo thêm cải thiện nhỏ cho tới gần cuối run.  
    Đường ECDF của GA nằm hơi lệch sang trái so với FA, tức GA thường có đoạn stagnation dài nhất ngắn hơn một chút. Điều này phù hợp với fixed-budget plot: GA khai thác rất mạnh trong vùng lân cận nghiệm hiện tại và liên tục tạo ra cải thiện nhỏ, nhưng vẫn không đạt được sai số thấp như FA.
    
    \item \textbf{Multimodal\_escape (30 chiều).}  
    Khi dimension tăng, tương quan đảo chiều. Histogram và ECDF cho thấy GA thường có đoạn stagnation dài hơn: nhiều run của GA có stagnation vượt quá 300 thế hệ, trong khi phần lớn run của FA dừng dưới khoảng 220–240 thế hệ.  
    Nghĩa là trên landscape đa cực trị phức tạp hơn, GA dễ bị “đóng băng” trong một basin: quần thể đã đồng nhất (đa dạng gần 0) nhưng cơ chế đột biến / lai ghép không đủ mạnh để tạo ra bước nhảy mang tính phá vỡ.
    
    \item \textbf{Scalability (50 chiều).}  
    Ở cấu hình khó nhất, sự chênh lệch càng rõ: ECDF của FA nằm cao hơn GA trên toàn trục hoành. Khoảng 70–80\% run của FA có đoạn stagnation dài nhất dưới 200 thế hệ, trong khi GA phải tới khoảng 300–350 thế hệ mới đạt mức ECDF tương đương.  
    Điều này khớp với ERT và ECDF fixed-target: FA dù vẫn thất bại trên nhiều run nhưng vẫn tạo được một số cải thiện muộn (late improvements), còn GA gần như bị “lock” trong vùng nghiệm kém trong phần lớn thời gian chạy.
\end{itemize}


\subsubsection{Knapsack: hiệu năng fixed-budget (gap tới nghiệm tối ưu)}

Trong bài toán Knapsack, ta dùng thước đo \emph{Gap to Optimal} (\%) sau khi tiêu tốn một tỉ lệ cố định của ngân sách đánh giá (10\%, 30\%, 50\% và 100\%).  
Gap được định nghĩa ở Mục~\ref{subsec:Chi_so_danh_gia}{;} giá trị nhỏ hơn là tốt hơn, và các giá trị quanh \(200\%\) tương ứng với việc thuật toán chỉ đạt được khoảng một nửa giá trị tối ưu.

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_fixed_budget_Gap_10pct.png}
\caption{Knapsack – fixed-budget gap tại 10\% ngân sách cho ba kích thước bài toán \(N \in \{50, 100, 200\}\).}
\label{fig:knapsack_fb_10}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_fixed_budget_Gap_30pct.png}
\caption{Knapsack – fixed-budget gap tại 30\% ngân sách.}
\label{fig:knapsack_fb_30}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_fixed_budget_Gap_50pct.png}
\caption{Knapsack – fixed-budget gap tại 50\% ngân sách.}
\label{fig:knapsack_fb_50}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_fixed_budget_Gap_100pct.png}
\caption{Knapsack – fixed-budget gap tại 100\% ngân sách.}
\label{fig:knapsack_fb_100}
\end{figure}

Các kết quả này cho thấy một bức tranh rất khác so với Rastrigin:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Mức độ khó tổng thể.}  
    Ở mọi cấu hình, median gap của bốn thuật toán đều nằm trong dải \(190\%{-}200\%\). Điều này cho thấy các metaheuristic đang làm việc trong một landscape tổ hợp rất khó: lời giải thu được thường chỉ đạt xấp xỉ một nửa giá trị tối ưu.  
    Việc tăng ngân sách từ 10\% lên 100\% chỉ giúp giảm gap thêm một vài đơn vị phần trăm, nghĩa là phần lớn lợi ích đã được “ăn” trong giai đoạn rất sớm; ngân sách còn lại chủ yếu làm thu hẹp phương sai giữa các lần chạy và kéo dài đuôi dưới.

    \item \textbf{Xếp hạng giữa các thuật toán.}  
    Thứ hạng tương đối giữa bốn thuật toán khá ổn định trên mọi \(N\) và mọi mức ngân sách:
    \begin{itemize}
        \item \textbf{FA tệ nhất một cách ổn định.}  
        Boxplot của FA gần như “dính” ở vùng gap xấp xỉ \(200\%\) với phương sai rất nhỏ, gần như không có đuôi dưới. FA hội tụ nhanh vào một vùng nghiệm kém và hầu như không cải thiện thêm khi tăng ngân sách.
        \item \textbf{GA cho chất lượng điển hình tốt nhất.}  
        Trong hầu hết các panel, GA có median gap thấp nhất (hoặc ngang ngửa SA nhưng ổn định hơn), phân bố tập trung hơn quanh giá trị \(\approx 190\%\). GA rõ ràng là thuật toán cho “chất lượng trung bình” tốt nhất trên Knapsack trong bộ thực nghiệm này.
        \item \textbf{SA có những lời giải tốt nhất nhưng hiếm.}  
        Median của SA thường nhỉnh hơn GA một chút, nhưng SA là thuật toán duy nhất có đuôi dưới kéo dài xuống vùng \(150\%{-}170\%\), thể hiện một số run hiếm hoi tìm được lời giải tốt vượt trội so với phần còn lại. Nói cách khác, SA không phải là tốt nhất về mặt điển hình, nhưng lại có tiềm năng sinh ra những nghiệm rất tốt khi “gặp may”.
        \item \textbf{HC nằm giữa GA và FA.}  
        HC có median thấp hơn FA nhưng cao hơn GA và thường không chạm được tới những nghiệm rất tốt như SA. Phân bố của HC dày đặc quanh một vùng gap cố định, cho thấy một chiến lược khai thác địa phương tương đối hiệu quả nhưng thiếu các bước nhảy đủ xa để tạo ra những lời giải đột phá.
    \end{itemize}
    
    \item \textbf{Ảnh hưởng của kích thước bài toán.}  
    Khi tăng số lượng vật phẩm từ \(N=50\) lên \(N=200\), median gap của từng thuật toán chỉ dao động nhẹ quanh ngưỡng \(190\%{-}200\%\), và thứ hạng tương đối hầu như không thay đổi. Độ khó mà các thuật toán đang gặp phải vì vậy có vẻ đến từ \emph{cấu trúc} instance và cơ chế cập nhật hơn là riêng yếu tố số biến. Ở mọi \(N\), SA vẫn là thuật toán duy nhất có đuôi dưới rất sâu, GA vẫn giữ median thấp nhất, trong khi FA luôn nằm sát phía trên.
    
    \item \textbf{Ảnh hưởng của ngân sách.}  
    So sánh bốn mức ngân sách cho thấy:
    \begin{itemize}
        \item FA hầu như không phản ứng với việc tăng ngân sách – median và phương sai gần như bất biến. Đây là dấu hiệu của \emph{stagnation triệt để}: thêm đánh giá chỉ lặp lại các bước nhảy quanh một vùng nghiệm tệ.
        \item GA, HC và đặc biệt là SA có cải thiện chủ yếu ở phần tail: khi ngân sách tăng, số lượng run đạt được gap tốt (đuôi dưới) tăng lên, nhưng median chỉ nhích xuống rất nhẹ. Các thuật toán này do đó phụ thuộc khá nhiều vào một số run “may mắn”; để cải thiện một cách đáng tin cậy hơn, cần hoặc ngân sách lớn hơn đáng kể, hoặc các chiến lược đa khởi tạo / tái khởi tạo rõ ràng.
    \end{itemize}
\end{itemize}


\vspace{0.5em}

\subsubsection{Knapsack: performance/data profiles và so sánh thống kê}

%----------------- HÌNH CHO 1.6.4 -----------------

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_data_profiles.png}
\caption{Data profile Moré--Wild cho Knapsack.}
\label{fig:knapsack_data_profile}
\end{figure}

Đối với Knapsack, data profile Moré--Wild $\psi(\nu)$ trong Hình~\ref{fig:knapsack_data_profile} không còn suy biến như trường hợp Rastrigin.  
Với tập target được chọn, FA đạt giá trị $\psi(\nu)$ cao nhất trên toàn dải ngân sách: ngay từ $\nu \approx 10^2$ đã giải được hơn một nửa số cặp (bài toán, target), và khi $\nu$ tiến tới $10^4$ thì đường của FA gần như chạm tới 1.  
HC đứng thứ hai với mức phủ khoảng $0.8$, trong khi GA và SA dừng lại quanh $0.6{-}0.65$.  
Nói cách khác, dưới một định nghĩa thành công khá “thoáng” (gap tới tối ưu không cần quá nhỏ), FA là thuật toán có xác suất cao nhất đưa nghiệm vào vùng “chấp nhận được” trong ngân sách cho trước; HC theo sau, còn GA và SA chậm hơn đáng kể.  
Tuy nhiên, các ngưỡng target này vẫn tương đối xa tối ưu, nên data profile phản ánh chủ yếu khả năng đạt \emph{xấp xỉ thô} hơn là khả năng tiệm cận nghiệm tối ưu thực sự.

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_performance_profiles.png}
\caption{Performance profile Dolan--Moré cho Knapsack, dùng số phép đánh giá để đạt target làm metric.}
\label{fig:knapsack_perf_profile}
\end{figure}

Performance profile Dolan--Moré trong Hình~\ref{fig:knapsack_perf_profile} củng cố bức tranh đó.  
Đường $\varphi(\tau)$ của FA nằm rất cao ngay từ những giá trị $\tau$ nhỏ: với một hệ số hiệu năng khiêm tốn, FA đã giải được gần như toàn bộ các cặp (bài toán, target) nhanh nhất hoặc gần nhanh nhất trong tập thuật toán.  
Ba thuật toán còn lại chỉ dần bắt kịp khi $\tau$ tăng lên vài bậc độ lớn, cho thấy chúng thường cần nhiều phép đánh giá hơn FA để đạt cùng một target “dễ”.  
Giữa ba baseline, HC và SA nhìn chung nằm phía trên GA trong phần lớn dải $\tau$, tức là về tốc độ đạt target thô thì GA thậm chí còn kém cạnh hơn.  

Quan trọng là, cũng như với data profile, performance profile ở đây hoàn toàn \emph{tương đối}: metric được chuẩn hoá theo thuật toán tốt nhất trên từng cặp (bài toán, target), và target lại là các ngưỡng gap khá lỏng.  
Vì vậy, việc FA “thống trị” Hình~\ref{fig:knapsack_perf_profile} chỉ nói rằng FA hiếm khi tệ nhất và rất ổn định trong việc đạt một mức xấp xỉ tương đối, chứ không hề phủ định kết luận từ các biểu đồ fixed-budget rằng nghiệm cuối của FA vẫn cách rất xa tối ưu.

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_pairwise_heatmap_overall.png}
\caption{Heatmap số lần thắng--thua có ý nghĩa thống kê giữa các cặp thuật toán trên toàn bộ nghiệm cuối.}
\label{fig:knapsack_pairwise_overall}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_copeland_ranking.png}
\caption{Điểm Copeland (thắng trừ thua) cho từng thuật toán Knapsack.}
\label{fig:knapsack_copeland}
\end{figure}

Để có một bức tranh cân bằng hơn, chúng tôi dựa vào so sánh thống kê cặp đôi và điểm Copeland.  
Hình~\ref{fig:knapsack_pairwise_overall} cho thấy mọi thuật toán còn lại đều áp đảo FA: GA thắng FA 72 lần có ý nghĩa thống kê, HC thắng 58 lần và SA thắng 62 lần, trong khi FA chỉ thắng được HC đúng 3 lần và không có trận thắng nào trước GA hoặc SA.  
Giữa ba thuật toán GA, HC và SA, cán cân nghiêng rõ về phía SA: SA thắng GA 39 lần trong khi GA chỉ thắng SA 21 lần; SA thắng HC 52 lần và HC hoàn toàn không có trận thắng đáng kể nào trước SA.  
GA lại thắng HC 55 lần so với 6 lần ngược lại, nên xét theo đối đầu trực tiếp, trật tự ưu thế tổng quát là SA $>$ GA $>$ HC $>$ FA.  

Điểm Copeland trong Hình~\ref{fig:knapsack_copeland} tóm tắt gọn các quan sát này: SA đạt $+132$ điểm, GA đạt $+103$, HC ở mức $-46$ và FA rơi xuống $-189$.  
Như vậy, dù FA trông rất “đẹp” dưới lăng kính data/performance profile, khi đánh giá bằng số trận thắng--thua có ý nghĩa thống kê trên toàn bộ tập nghiệm thì SA vẫn là thuật toán chiếm ưu thế rõ rệt nhất, GA là đối thủ cạnh tranh trực tiếp, HC là trung bình và FA là lựa chọn kém nhất.

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_pairwise_heatmap_penalty.png}
\caption{Heatmap thắng--thua khi chỉ xét chất lượng nghiệm penalty (trước pha repair).}
\label{fig:knapsack_pairwise_penalty}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_pairwise_heatmap_repair.png}
\caption{Heatmap thắng--thua khi chỉ xét chất lượng nghiệm sau pha repair.}
\label{fig:knapsack_pairwise_repair}
\end{figure}

Hai heatmap bổ sung trong Hình~\ref{fig:knapsack_pairwise_penalty} và~\ref{fig:knapsack_pairwise_repair} giúp tách riêng vai trò của pha penalty và pha repair.  
Ở mức penalty (trước khi repair), SA nổi bật nhất: SA thắng GA 28 lần và thắng HC 28 lần, trong khi GA không có trận thắng nào trước SA. GA vẫn thắng HC 22 lần so với 6 lần thua, và cả GA, HC, SA đều thắng FA 36 lần.  
Điều này gợi ý rằng quỹ đạo tìm kiếm của SA tạo ra nhiều nghiệm “thô” có giá trị mục tiêu rất tốt (dù còn vi phạm ràng buộc), GA đứng thứ hai, còn HC và đặc biệt là FA sinh ra các nghiệm penalty kém cạnh hơn nhiều.  

Sau pha repair (Hình~\ref{fig:knapsack_pairwise_repair}), bức tranh thay đổi phần nào. GA lúc này tương tác rất tốt với heuristic repair: GA thắng SA 21 lần, trong khi SA chỉ thắng GA 11 lần; GA cũng thắng HC 33 lần và thắng FA 36 lần. SA vẫn thắng HC 24 lần và thắng FA 26 lần, còn HC thắng FA 22 lần (FA chỉ gỡ gạc được 3 trận thắng trước HC).  
Nói cách khác, repair đã “bù đắp” một phần bất lợi ban đầu của GA, giúp GA tận dụng tốt các nghiệm penalty của mình để xây dựng nghiệm khả thi chất lượng cao, trong khi SA vẫn giữ được ưu thế nhưng không còn vượt trội tuyệt đối.

Kết hợp tất cả các lát cắt trên, bức tranh cuối cùng cho Knapsack là:  
FA tuy có data/profile rất đẹp nhờ ổn định và nhanh đạt target thô, nhưng về chất lượng nghiệm cuối và số lần thắng có ý nghĩa thống kê thì liên tục bị các thuật toán còn lại chi phối và có thể xem như một baseline đơn giản.  
HC cải thiện rõ rệt so với FA nhưng hiếm khi vượt được GA và SA.  
GA là đối thủ mạnh thứ hai: sau pha repair, GA cho chất lượng điển hình tốt nhất và thường xuyên thắng HC, đôi khi thua SA trên các instance khó.  
SA là thuật toán thể hiện tốt nhất về tổng thể, đặc biệt mạnh ở giai đoạn penalty và trong các so sánh cặp đôi, dẫn đến điểm Copeland cao nhất.  
Dù vậy, cả bốn thuật toán vẫn đang hoạt động trong vùng \emph{xấp xỉ thô}: các fixed-budget boxplot cho thấy gap tới nghiệm tối ưu còn rất lớn, nên mọi kết luận về Knapsack trong báo cáo này cần được hiểu là so sánh giữa các metaheuristic chưa hội tụ, chứ không phải giữa những thuật toán đã thực sự giải được bài toán tới gần mức tối ưu.

\vspace{0.5em}

\subsubsection{Thảo luận}

\paragraph{Rastrigin: giới hạn của bộ thuật toán trong bối cảnh high-dimensional.}

Khi đặt ERT và performance profiles cạnh ECDF và data profiles, bức tranh trở nên rõ ràng hơn rất nhiều: các tín hiệu “tốt” của GA và FA ở dimension thấp không kéo dài được sang dimension cao.

\begin{itemize}[leftmargin=1.6em]
    \item Ở 10 chiều, GA và FA giảm sai số cuối đáng kể so với HC và SA, nhưng tỷ lệ thành công cho các target khó vẫn không cao.
    \item Ở 30 và 50 chiều, cả bốn thuật toán gần như đồng loạt “chựng lại”: ECDF phẳng, data profiles có coverage rất thấp và đa phần các lần chạy dừng xa optimum.
    \item GA vẫn là lựa chọn tương đối tốt nhất trong bốn thuật toán, nhưng chỉ theo nghĩa tương đối. Xét giá trị tuyệt đối, không thuật toán nào tiệm cận mức “giải tốt Rastrigin high-dimensional” dưới ngân sách hiện hành.
\end{itemize}

Do đó, phần Rastrigin của benchmark không nhằm tìm ra thuật toán “giải trọn” bài toán, mà nhằm minh hoạ giới hạn vận hành của bốn heuristic này khi dimensionality tăng và ngân sách hạn chế.

\paragraph{Firefly Algorithm trên Rastrigin: tác động của độ suy giảm hấp dẫn.}

FA trên không gian continuous high-dimensional gặp điểm nghẽn quen thuộc:

\[
\beta(r) = \beta_0 \exp(-\gamma r^2).
\]

Khoảng cách điển hình trong không gian $d$ chiều tăng theo $\sqrt{d}$; vì vậy nếu $\gamma$ không được giảm mạnh theo $d$, thì $\beta(r)$ gần như bị triệt tiêu. Điều này đúng trong toàn bộ thí nghiệm:

\begin{itemize}[leftmargin=1.6em]
    \item Dù đã giảm $\gamma$ theo dimension, mức giảm vẫn không đủ để giữ tương tác giữa các cá thể.
    \item Khi $\beta(r)$ nhỏ, FA thoái hoá thành một dạng random walk có nhiễu: di chuyển nhiều nhưng không “hút” nhau, dẫn tới không thể chui sâu vào basin tốt trong thời gian hữu hạn.
\end{itemize}

Điểm này gợi ý rằng muốn FA cạnh tranh được trên continuous high-dimensional, cần cơ chế điều chỉnh $\gamma$ và $\alpha$ theo thời gian hoặc theo phân bố quần thể thay vì giữ cố định.

\paragraph{Knapsack: FA rời rạc giữa tốc độ hội tụ và chất lượng nghiệm cuối.}

Trên Knapsack, FA rời rạc kết hợp repair heuristic vẫn có một số điểm mạnh rất rõ, nhưng không còn là “người thắng tuyệt đối” nếu nhìn vào chất lượng nghiệm cuối và so sánh thống kê.

\begin{itemize}[leftmargin=1.6em]
    \item Cơ chế lật bit có hướng khiến FA rất phù hợp để nhanh chóng đẩy nghiệm về một vùng có giá trị mục tiêu chấp nhận được trong không gian 0/1; data profile cho thấy FA đạt coverage cao với các ngưỡng gap tương đối “thoáng”.
    \item Greedy repair theo tỷ số $v_k / w_k$ giúp khôi phục feasibility và cải thiện giá trị mục tiêu, nên mỗi bước repair vẫn giống một pha tối ưu hoá cục bộ hợp lý.
    \item Tuy nhiên, các boxplot fixed-budget cho thấy median gap của FA gần như luôn cao nhất trong bốn thuật toán, với phương sai nhỏ và ít tail tốt: FA hội tụ nhanh nhưng bị kẹt trong vùng nghiệm kém và không tận dụng thêm ngân sách.
    \item So sánh cặp đôi và điểm Copeland củng cố kết luận này: GA và đặc biệt là SA thắng FA một cách có hệ thống cả ở mức penalty lẫn sau repair, trong khi HC cũng thường xuyên vượt lên FA.
\end{itemize}

Nói cách khác, trong biến thể rời rạc hiện tại, FA là một \emph{baseline nhanh và ổn định} để đạt xấp xỉ thô trên Knapsack 0/1, nhưng \emph{không phải} thuật toán tốt nhất nếu quan tâm tới chất lượng nghiệm cuối sát tối ưu; vai trò đó thuộc về SA (mạnh nhất về tổng thể) và GA (đối thủ cạnh tranh trực tiếp, tương tác rất tốt với repair).

\paragraph{Ý nghĩa và hạn chế của performance/data profiles khi success rate thấp hoặc target “thoáng”.}

Dolan–Moré performance profile và Moré–Wild data profile là công cụ so sánh mạnh, nhưng rất dễ gây ảo giác nếu success rate thấp hoặc nếu tập target được chọn quá lỏng:

\begin{itemize}[leftmargin=1.6em]
    \item Performance profile chỉ xét những run đạt target $\Rightarrow$ một thuật toán có ít run thành công vẫn có thể trông “đẹp” nếu số ít lần thành công đó xảy ra nhanh.
    \item Data profile phản ánh coverage tốt hơn nhưng phụ thuộc mạnh vào cách chọn target và ngân sách; nếu target chỉ yêu cầu gap thô, thì một thuật toán nhanh nhưng dừng sớm vẫn được đánh giá cao.
\end{itemize}

Trong báo cáo này:

\begin{itemize}[leftmargin=1.6em]
    \item Rastrigin high-dimensional: GA và FA trông tương đối tốt trên performance profile, nhưng ECDF và data profile cho thấy coverage rất thấp ở các target khó; phần lớn run không thật sự giải được bài toán.
    \item Knapsack: data/profile cho thấy FA có tốc độ và độ ổn định rất cao để đạt các ngưỡng gap tương đối lỏng, nhưng khi đối chiếu với fixed-budget gap và so sánh cặp đôi/Copeland, rõ ràng GA và đặc biệt là SA cho nghiệm cuối tốt hơn và áp đảo FA về mặt thống kê.
\end{itemize}

Kinh nghiệm rút ra là: performance/data profiles luôn phải được đọc cùng với ECDF, fixed-budget gap và phân tích thống kê, đặc biệt khi ta chỉ đang làm việc với các mức xấp xỉ thô, chưa tiệm cận optimum.

\paragraph{Không có thuật toán tối ưu “mọi nơi”: liên hệ với No Free Lunch.}

Ngay trong hai bài toán của benchmark, tính “không miễn phí” thể hiện rõ:

\begin{itemize}[leftmargin=1.6em]
    \item Trên Rastrigin continuous (đặc biệt ở 10 chiều), GA mạnh hơn ba thuật toán còn lại cả về sai số cuối lẫn xác suất đạt các target khó, dù bản thân nó vẫn chưa “giải tốt” bài toán ở dimension cao.
    \item Trên Knapsack 0/1, SA là thuật toán mạnh nhất về tổng thể (Copeland cao nhất, tail nghiệm tốt nhất), GA là đối thủ cạnh tranh trực tiếp nhờ tương tác tốt với repair, trong khi FA chủ yếu nổi bật ở khả năng nhanh chóng đạt được xấp xỉ thô và độ ổn định cao trên các target lỏng.
    \item HC và đặc biệt là FA hiếm khi đứng đầu về chất lượng nghiệm cuối, nhưng là baseline quan trọng để đánh giá mặt bằng độ khó và để phân tách rõ vai trò của local search đơn giản so với các metaheuristic phức tạp hơn.
\end{itemize}

Điểm cốt lõi: \emph{hiệu năng phụ thuộc bài toán} (landscape, ràng buộc, cách mã hoá, ngân sách), không có solver nào thống trị toàn bộ.

\paragraph{Bài học về thiết kế benchmark và cách diễn giải kết quả.}

Một số kinh nghiệm rút ra từ quá trình xây dựng pipeline:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Metric phải đúng:} nhầm hướng cực trị khiến performance/data profile phẳng hoàn toàn — bài học lớn nhất khi phân tích Rastrigin.
    \item \textbf{ERT phải đi cùng success rate:} nếu không, ERT trên target khó trở nên vô nghĩa.
    \item \textbf{Hyperparameter cố định theo kịch bản:} thiết kế này đảm bảo công bằng, nhưng chỉ đại diện cho “out-of-the-box baseline”, không phải hiệu năng tối ưu.
    \item \textbf{Kết luận phải phản ánh giới hạn:} báo cáo tốt phải dám chỉ ra nơi thuật toán thất bại (ví dụ FA trên Rastrigin high-dimensional, hay FA trên Knapsack nếu xét nghiệm cuối) thay vì chỉ nhấn mạnh điểm mạnh.
\end{itemize}

\paragraph{Tổng kết.}

Benchmark này cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item Trên Rastrigin, không thuật toán nào đạt mức giải strong khi dimension tăng; GA vẫn là lựa chọn tương đối tốt nhất trong bốn, nhưng chỉ theo nghĩa tương đối.
    \item Trên Knapsack, FA rời rạc kết hợp greedy repair là một baseline nhanh và ổn định để đạt xấp xỉ thô, thể hiện rất tốt trên data/performance profiles với các target lỏng; tuy nhiên, về chất lượng nghiệm cuối và so sánh thống kê, SA là thuật toán mạnh nhất, GA là đối thủ cạnh tranh trực tiếp, HC đứng giữa, còn FA thường xuyên là lựa chọn kém nhất.
\end{itemize}

Giá trị của benchmark không nằm ở việc tìm một “người thắng tuyệt đối”, mà ở việc chỉ ra thuật toán nào phù hợp với cấu trúc nào, dưới ngân sách nào — và minh bạch về nơi mỗi thuật toán thất bại.



\subsection{Cuckoo Search}

\begin{itemize}
  \item CS hoạt động rất tốt trên hàm lồi như \textbf{Sphere}.
  \item Trên hàm đa cực như \textbf{Rastrigin}, CS chưa tìm đến giá trị tối ưu 0, còn GA đạt 0. Nguyên nhân phổ biến:
  \begin{itemize}
    \item Rastrigin có nhiều local minima; CS có cơ chế Lévy giúp khám phá, nhưng tham số (step\_size, $p_a$, $\beta$, số cá thể) có thể chưa phù hợp.
    \item GA có cơ chế mutation và có thể dễ dàng duy trì tính đa dạng quần thể nếu được cấu hình tốt.
  \end{itemize}
  \item CS có ít tham số và đơn giản hơn; GA có nhiều thao tác (selection/crossover/mutation) cho phép đa dạng nghiệm mạnh hơn.
\end{itemize}
\begin{itemize}
    \item Trong thực nghiệm thì CS chạy nhanh hơn GA ở cùng quy mô và số vòng lặp, nhưng yếu tố này phụ thuộc vào cài đặt chi tiết (vectorization, cách tính fitness, chi phí crossover/mutation...).
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{picture/cs-ga.png}
    \caption{Kết quả so sánh CS và GA trên Rastrigin 10D}
    \label{fig:cs_ga_compare}
\end{figure}
\item Hình~\ref{fig:cs_ga_compare} trình bày đường hội tụ của hai thuật toán Cuckoo Search (CS) và Genetic Algorithm (GA) trên hàm Rastrigin trong không gian 10 chiều. Kết quả cho thấy GA giảm giá trị fitness nhanh và ổn định hơn, trong khi CS có xu hướng chậm lại sau một số vòng lặp đầu và bị kẹt tại mức fitness cao hơn. Điều này minh họa sự khác biệt trong khả năng khai thác cục bộ của GA và khả năng khám phá mang tính ngẫu nhiên mạnh của CS.
\end{itemize}

