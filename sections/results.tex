% sections/results.tex – Results and conclusion section

\section{Thiết lập và phân tích kết quả các bài toán đánh giá}
\subsection{ACO}
\subsection{PSO}
\subsection{ABC}
Sau nhiều lần thử với nhiều loại bài toán khác nhau, ta thấy thuật toán ABC có độ ổn định cao, performance tốt với cả những hàm số đa cực trị hay có cực trị đặc biệt
\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{picture/ras_1.png}
        \caption{Sau lần 10}
    \end{minipage}
    \begin{minipage}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{picture/ras_2.png}
        \caption{Sau lần 30}
    \end{minipage}
    \begin{minipage}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{picture/ras_3.png}
        \caption{Kết quả}
    \end{minipage}
\end{figure}

So sánh với các thuật giải truyền thống: như đã nói ở trên, thuật toán ABC có performance cao, giải quyết tốt những bài toán mà các thuật toán truyền thống không giải được, chẳng hạn như hàm rastrigin:
\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{picture/ras_compare.png}
    \label{fig:placeholder1}
\end{figure}
\newpage
Tuy nhiên ABC cũng có điểm hạn chế, đó là tốc độ chậm hơn đáng kể so với các thuật toán truyền thống như hill climbing hay stimulated annealing, đặc biệt là trong một số bài toán không quá phức tạp, chẳng hạn như hàm circle (nửa dưới hình cầu):

\begin{figure}[h]
    \centering
    \includegraphics[width=0.25\linewidth]{picture/cir_compare.png}
    \label{fig:placeholder2}
\end{figure}

Ngoài ra, bộ nhớ sử dụng trong thuật toán ABC cũng nhiều hơn, tỉ lệ thuận với số lượng "con ong" được sử dụng.
\subsection{Firefly Algorithm}

\subsubsection{Thuật toán dùng để so sánh}

Để đặt Thuật toán Đom Đóm (FA) vào bối cảnh hợp lý, chúng tôi so sánh với ba thuật toán metaheuristic cổ điển: Hill Climbing (HC), Simulated Annealing (SA) và Genetic Algorithm (GA).  
Toàn bộ thuật toán được hiện thực trong cùng một khung mã Python, dùng chung: (i) giao diện bài toán, (ii) cơ chế sinh nghiệm khởi tạo, (iii) chuẩn hoá cách ghi log (history, số đánh giá, trạng thái run, \dots) và (iv) pipeline phân tích/visualize dùng chung cho cả Rastrigin và Knapsack.

\paragraph{Hill Climbing (HC).}
HC là baseline tham lam địa phương: luôn giữ một nghiệm hiện tại, sinh lân cận và chỉ chấp nhận nghiệm tốt hơn; khi không cải thiện sau một số vòng lặp thì restart.

\textbf{Triển khai trong framework.}
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Rastrigin (liên tục):} nghiệm được mã hoá dưới dạng vector thực; lân cận sinh bằng perturbation ngẫu nhiên trên từng chiều (Gaussian/Uniform tuỳ cấu hình). Mỗi vòng lặp đánh giá một tập lân cận có kích thước cố định và chọn best improvement. Số vòng lặp hiệu dụng được suy ra từ budget và số lân cận mỗi vòng.
    \item \textbf{Knapsack (0/1):} nghiệm là vector nhị phân; lân cận sinh bằng bit-flip trên một số vị trí; khi bị kẹt lâu trên plateau (không cải thiện trong một số vòng) thì restart. Hàm mục tiêu dùng đúng cùng quy ước với các thuật toán khác (maximize giá trị, đồng thời kiểm tra ràng buộc).
\end{itemize}

\paragraph{Simulated Annealing (SA).}
SA dùng cùng cấu trúc lân cận với HC, nhưng cho phép chấp nhận nghiệm xấu hơn với xác suất
\[
    \mathbb{P}(\text{chấp nhận}) = \exp\!\left(-\frac{\Delta f}{T}\right),
\]
trong đó $T$ là nhiệt độ, giảm dần theo lịch làm nguội hình học
$T_{k+1} = \text{cooling\_rate} \cdot T_k$ cho tới khi chạm $T_{\min}$.

\textbf{Triển khai trong framework.}
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Rastrigin (liên tục):} dùng cùng kiểu perturbation như HC để đảm bảo so sánh công bằng; nhiệt độ khởi tạo $T_0$ tương đối cao, hệ số làm nguội gần 1, và $T_{\min}$ cố định cho mọi cấu hình.
    \item \textbf{Knapsack (0/1):} vẫn dùng lân cận bit-flip; chỉ điều chỉnh $T_0$ và \texttt{cooling\_rate}. Mỗi bước đánh giá đúng một nghiệm mới, nên số vòng lặp bằng budget.
\end{itemize}

\paragraph{Genetic Algorithm (GA).}
GA duy trì một quần thể cá thể và lặp lại chu trình: chọn lọc (tournament selection), lai ghép (crossover) và đột biến (mutation), kèm một mức elitism để giữ lại các cá thể tốt nhất qua thế hệ.

\textbf{Triển khai trong framework.}
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Rastrigin (liên tục):} cá thể là vector thực chiều $d$; crossover và mutation được thiết kế cho không gian liên tục, với tỉ lệ crossover/mutation và kích thước quần thể \texttt{pop\_size} được cố định theo từng cấu hình Rastrigin trong \texttt{config.py}. Budget tổng được phân bổ thành $ \text{max\_iter} \times \text{pop\_size}$ lượt đánh giá.
    \item \textbf{Knapsack (0/1):} cá thể là vector nhị phân; crossover và mutation đều thao tác trên bit; \texttt{pop\_size} tăng theo kích thước bài toán (lớn hơn cho $n=200$ so với $n=50,100$). Trong mọi trường hợp luôn bật elitism và sử dụng tournament selection với kích thước giải đấu cố định.
\end{itemize}

\paragraph{Firefly Algorithm (FA).}
FA mô phỏng bầy đom đóm trong đó mỗi nghiệm là một cá thể phát sáng; cá thể kém sáng di chuyển về phía cá thể sáng hơn với cường độ phụ thuộc khoảng cách và tham số hấp dẫn $\beta_0$, trong khi thành phần nhiễu có biên độ $\alpha$ giúp duy trì khả năng khám phá.

\textbf{FA liên tục cho Rastrigin.}
FA được dùng dưới dạng chuẩn trong không gian liên tục: vị trí đom đóm là vector thực, khoảng cách được tính trong không gian Euclid, và chuyển động kết hợp giữa thành phần hút (về các nghiệm tốt hơn) và nhiễu ngẫu nhiên.  

Ba cấu hình Rastrigin trong \texttt{config.py}—\texttt{quick\_convergence} ($d=10$), \texttt{multimodal\_escape} ($d=30$) và \texttt{scalability} ($d=50$)—mỗi cấu hình có một bộ tham số FA riêng (số đom đóm, $\alpha$, $\beta_0$, $\gamma$) đã được cố định trước. Điểm chung là:
\begin{itemize}[leftmargin=1.6em]
    \item Khi dimension tăng, \texttt{n\_fireflies} và budget tăng để bù lại độ khó cao hơn.
    \item $\alpha$ được điều chỉnh trong khoảng giá trị vừa đủ để tránh hội tụ quá sớm nhưng không làm thuật toán trở nên hoàn toàn ngẫu nhiên.
    \item $\gamma$ giảm dần khi $d$ tăng nhằm tránh việc lực hút bị triệt tiêu quá nhanh do khoảng cách tăng theo $\sqrt{d}$.
\end{itemize}

\textbf{FA rời rạc cho Knapsack.}\cite{pisinger2005hard}
Đối với Knapsack 0/1, chúng tôi dùng biến thể FA đã rời rạc hoá, đúng với cấu hình trong \texttt{config.py} và \texttt{instance\_generator.py}:
\begin{itemize}[leftmargin=1.6em]
    \item \emph{Biểu diễn:} mỗi đom đóm là một vector nhị phân chiều $n$.
    \item \emph{Chuyển động có hướng:} khi một cá thể di chuyển về phía cá thể sáng hơn, nó lật tối đa \texttt{max\_flips\_per\_move} $=3$ bit để tiến lại gần cấu hình đích.
    \item \emph{Nhiễu:} ngoài chuyển động có hướng, mỗi bit còn có xác suất bị lật do nhiễu $\alpha_{\text{flip}} = 0{,}2$ để duy trì đa dạng.
    \item \emph{Ràng buộc:} luôn dùng chiến lược repair \texttt{greedy\_remove} (loại dần các vật phẩm có tỉ lệ $v_k/w_k$ thấp nhất) để đưa nghiệm trở về trạng thái feasible. Cơ chế penalty vẫn được hỗ trợ trong code, nhưng trong benchmark chính, cấu hình được dùng là repair.
    \item \emph{Quần thể và budget:} số đom đóm \texttt{n\_fireflies} tăng theo kích thước bài toán: với $n \le 100$ dùng $30$ đom đóm, với $n=200$ dùng $40$; budget tổng tương ứng là $5000$ và $10000$ lần đánh giá, phân bổ thành $\text{max\_iter} \times \text{n\_fireflies}$.
\end{itemize}

\paragraph{Lưu ý về tham số.}
Các tham số \emph{không} dùng chung cho toàn bộ lớp bài toán, mà được cố định \textbf{theo từng kịch bản benchmark}:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Rastrigin:} mỗi cấu hình \texttt{quick\_convergence} (10D), \texttt{multimodal\_escape} (30D), \texttt{scalability} (50D) có một \emph{RastriginConfig} riêng trong \texttt{config.py}, chứa: dimension, budget, ngưỡng gold/silver/bronze và bộ tham số FA, SA, HC, GA tương ứng. Các tham số này được cố định cho toàn bộ 30 lần chạy (30 seeds) và không tune theo từng instance.
    \item \textbf{Knapsack:} \texttt{get\_knapsack\_configs()} sinh các cấu hình cho $n \in \{50,100,200\}$, mỗi cấu hình gắn với một loại instance (uncorrelated, weakly, strongly, inverse) và một instance\_seed $\in \{42,123,999\}$. Trong mỗi cấu hình, budget, \texttt{n\_fireflies} và \texttt{pop\_size} được scale theo $n$ như đã nêu; các tham số này cố định cho toàn bộ 30 lần chạy metaheuristic trên cùng một instance.
\end{itemize}

\vspace{0.5em}
\subsubsection{Bài toán đánh giá}

\paragraph{Hàm Rastrigin (liên tục).}
Hàm Rastrigin là một hàm kiểm thử kinh điển trong tối ưu hoá toàn cục: phi lồi, đa cực trị mạnh, với rất nhiều cực tiểu địa phương phân bố đều trong không gian nghiệm, và một cực tiểu toàn cục tại $\mathbf{0}$ với $f(\mathbf{0})=0$. Hàm chuẩn được định nghĩa trên miền $[-5{,}12, 5{,}12]^d$
\[
    f(\mathbf{x}) = 10d + \sum_{i=1}^d \left( x_i^2 - 10\cos(2\pi x_i) \right).
\]

Trong benchmark này, chúng tôi sử dụng ba cấu hình được định nghĩa tường minh trong \texttt{RASTRIGIN\_CONFIGS}:
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{\texttt{quick\_convergence}:} $d = 10$, budget $10^4$ đánh giá; mục tiêu là quan sát tốc độ hội tụ sớm của các thuật toán trên một phiên bản tương đối dễ.
    \item \textbf{\texttt{multimodal\_escape}:} $d = 30$, budget $3 \times 10^4$; nhấn mạnh khả năng thoát bẫy cục bộ khi không gian nghiệm mở rộng và số lượng cực tiểu địa phương tăng.
    \item \textbf{\texttt{scalability}:} $d = 50$, budget $5 \times 10^4$; đây là cấu hình khó nhất, dùng để kiểm tra xu hướng suy giảm hiệu năng khi tăng dimension trong điều kiện budget hữu hạn.
\end{itemize}
Mỗi cấu hình đi kèm một bộ ngưỡng chất lượng (gold/silver/bronze) riêng cho sai số so với optimum; các ngưỡng này được đặt nới lỏng dần khi dimension tăng và được sử dụng nhất quán trong toàn bộ pipeline phân tích.

\paragraph{Bài toán Knapsack 0/1 (rời rạc).}\cite{smithmiles2021revisiting}
Bài toán Knapsack 0/1 được mô hình hoá dưới dạng tối ưu hoá tổ hợp: cho trước $n$ vật phẩm với trọng lượng $w_k$ và giá trị $v_k$, cùng sức chứa $C$, tìm tập con các vật phẩm sao cho tổng trọng lượng không vượt quá $C$ và tổng giá trị là lớn nhất.

Các instance được sinh bằng \texttt{generate\_knapsack\_instance()} trong \texttt{instance\_generator.py} với bốn kiểu phân phối giá trị–trọng lượng chuẩn trong literature:
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{uncorrelated:} $v_k$ và $w_k$ độc lập, đều phân bố đều trên cùng một khoảng; không có cấu trúc tương quan rõ rệt.
    \item \textbf{weakly correlated:} $w_k$ được sinh trước, $v_k \approx w_k$ cộng thêm nhiễu nhỏ; tạo ra tương quan dương yếu.
    \item \textbf{strongly correlated:} $v_k = w_k + \text{const}$; tương quan dương mạnh, cấu trúc gần với trường hợp “giá trị tỷ lệ với trọng lượng”.
    \item \textbf{inverse:} $v_k$ giảm khi $w_k$ tăng (dựa trên $w_{\max}$); tạo ra tương quan âm, thường được xem là khó hơn với các heuristic tham lam. 
\end{itemize}
Sức chứa $C$ được đặt bằng một tỉ lệ cố định của tổng trọng lượng (capacity\_ratio trong code).

\textbf{Cấu hình benchmark.}\cite{dolan2002benchmarking,more2009benchmarking}
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Kích thước:} $n \in \{50, 100, 200\}$.
    \item \textbf{Instance:} với mỗi cặp $(n,\text{instance\_type})$, sinh 3 instance độc lập với \texttt{instance\_seed} $\in \{42,123,999\}$.
    \item \textbf{Budget:} nếu $n \le 100$ thì budget là $5000$ lần đánh giá; nếu $n=200$ thì budget là $10000$. Budget này được chuyển thành số vòng lặp cho từng thuật toán dựa trên kích thước quần thể/tập lân cận.
    \item \textbf{Nghiệm tối ưu:} với mọi instance có $n \le 200$, nghiệm tối ưu $z^\star$ được tính bằng Dynamic Programming (DP) trong \texttt{run\_knapsack.py} và được lưu lại trong metadata; đây là chuẩn cho mọi tính toán optimality gap.
    \item \textbf{Số lần chạy metaheuristic:} trên mỗi instance, mỗi thuật toán được chạy $30$ lần với seed khác nhau (seed $\in \{0,\dots,29\}$), đúng như danh sách \texttt{seeds} trong code.
\end{itemize}

\vspace{0.5em}
\subsubsection{Chỉ số đánh giá}
\label{subsec:Chi_so_danh_gia}
\paragraph{Rastrigin.}
Rastrigin được xem như bài toán minimization với nghiệm tối ưu toàn cục $f^\star = 0$. Trên tập kết quả thu được, chúng tôi sử dụng các chỉ số sau, bám sát chuẩn COCO/BBOB và các công trình về benchmarking tối ưu hoá:
\begin{itemize}[leftmargin=1.6em]
    \item \textbf{ECDF fixed-target:} hàm phân phối thực nghiệm của runtime (số đánh giá hàm) để đạt các mức sai số mục tiêu (gold/silver/bronze). Mỗi điểm trên đường cong biểu diễn tỉ lệ run đã đạt target trong không quá $N$ đánh giá.
    \item \textbf{Fixed-budget summary:} sai số cuối cùng tại một số mốc budget chuẩn hoá (ví dụ 10\%, 25\%, 50\%, 75\%, 100\% budget) được dùng để so sánh chất lượng nghiệm khi tài nguyên bị giới hạn.
    \item \textbf{ERT (Expected Running Time):} số lần đánh giá kỳ vọng để đạt một target nhất định. ERT được tính trên cả các run thành công và thất bại bằng công thức chuẩn trong literature: runtime của run thất bại được thay bằng budget và đưa vào mẫu.
    \item \textbf{Performance profiles:} theo định nghĩa của Dolan–Moré, performance profile là hàm phân phối của tỉ lệ hiệu năng $\rho_{p,s}$ giữa thuật toán $s$ và thuật toán tốt nhất trên cùng bài toán $p$. Biểu đồ thể hiện xác suất một thuật toán có $\rho_{p,s} \le \tau$ khi quét qua các problem.
    \item \textbf{Data profiles:} theo Moré–Wild, data profile đo tỉ lệ problem được giải tới một mức chất lượng cho trước trong budget chuẩn hoá $\nu$ (số đánh giá trên mỗi biến). Đây là góc nhìn “theo budget” bổ sung cho performance profile.
\end{itemize}
Mọi chỉ số runtime phía trên đều được tính dựa trên số đánh giá hàm (function evaluations), không dùng thời gian thực, để giảm nhiễu do khác biệt phần cứng.

\paragraph{Knapsack.}
Đối với Knapsack 0/1, chúng tôi khai thác việc có nghiệm tối ưu $z^\star$ từ DP để xây dựng các chỉ số dựa trên \emph{optimality gap}:
\[
    \text{gap} = \frac{z^\star - z_{\text{alg}}}{z^\star} \times 100\%,
\]
với $z_{\text{alg}}$ là giá trị nghiệm tốt nhất của thuật toán.

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Các tier chất lượng:} sử dụng ba ngưỡng
    \[
        1\%,\quad 5\%,\quad 10\%
    \]
    tương ứng với gold, silver, bronze, trùng với \texttt{KNAPSACK\_GAP\_THRESHOLDS} trong \texttt{config.py}. Các tier này được dùng vừa để đánh nhãn chất lượng nghiệm cuối cùng, vừa làm target cho các phân tích runtime.
    \item \textbf{Tỉ lệ thành công theo tier:} trên mỗi cấu hình $(n, \text{instance\_type})$, tính tỉ lệ run đạt gap $\le$ ngưỡng tương ứng trong budget cho phép.
    \item \textbf{Feasibility rate:} tỉ lệ nghiệm cuối cùng thoả ràng buộc sức chứa. Chỉ số này đặc biệt quan trọng khi so sánh các chiến lược xử lý ràng buộc (repair so với penalty).
    \item \textbf{Runtime và profile:} tương tự Rastrigin, chúng tôi xây dựng ECDF fixed-target, ERT, performance profiles và data profiles, nhưng target ở đây là các ngưỡng gap (1\%, 5\%, 10\%). Để đảm bảo ý nghĩa, các phân tích này chỉ sử dụng các instance có \texttt{has\_dp\_optimal} = True trong metadata.
\end{itemize}

Toàn bộ chỉ số trên được trích xuất tự động bởi \texttt{analyze\_results.py} dựa trên các JSON kết quả từ \texttt{run\_rastrigin.py} và \texttt{run\_knapsack.py}, sau đó được sử dụng bởi \texttt{visualize.py} để tạo các biểu đồ phục vụ đánh giá định tính và định lượng.


\vspace{0.5em}

\subsubsection{Rastrigin: mức độ tiệm cận nghiệm tối ưu và đặc trưng hội tụ}

\paragraph{ECDF theo ngưỡng mục tiêu.}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ecdf_quick_convergence.png}
\caption{ECDF cho quick\_convergence (dim=10).}
\label{fig:rastrigin_ecdf_quick}
\end{figure}

Đối với cấu hình 10 chiều, ECDF cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item Ở mức Bronze, cả FA và GA đều đạt tỉ lệ thành công rất cao: các đường ECDF tiệm cận 1 khi ngân sách tiến dần tới khoảng \(10^3\) lần đánh giá. FA có xu hướng đạt cùng mức ECDF với chi phí nhỏ hơn đôi chút, thể hiện lợi thế nhẹ về tốc độ hội tụ.
    \item HC chậm hơn rõ rệt: đường ECDF nằm thấp và tăng chậm, phản ánh việc thuật toán này thường bị kẹt trong các cực trị địa phương của Rastrigin ngay cả với ngưỡng Bronze.
    \item Ở mức Silver, sự khác biệt trở nên rõ ràng: chỉ FA (đặc biệt là cấu hình \emph{specialist}) duy trì được ECDF đáng kể (xấp xỉ \(0.6\)–\(0.7\)), trong khi GA và HC hầu như không chạm được ngưỡng trong ngân sách đang xét, các đường ECDF gần như bám sát trục hoành. FA vì vậy là thuật toán duy nhất còn hoạt động hiệu quả khi yêu cầu độ chính xác cao hơn trên Rastrigin 10 chiều.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ecdf_multimodal_escape.png}
\caption{ECDF cho multimodal\_escape (dim=30).}
\label{fig:rastrigin_ecdf_multimodal}
\end{figure}

Khi tăng lên 30 chiều, hình dạng ECDF cho thấy độ khó tăng rõ rệt:

\begin{itemize}[leftmargin=1.6em]
    \item Ở mức Bronze, chỉ còn các biến thể của FA (bản gốc và \emph{specialist}) đạt được tỉ lệ thành công đáng kể. Cả hai đường cong đều bị dịch sang phải, cần tới cỡ \(10^4\) đánh giá để ECDF tiệm cận 1; cấu hình \emph{specialist} đạt cùng mức ECDF với chi phí thấp hơn, cho thấy việc tinh chỉnh tham số giúp cải thiện rõ rệt khả năng thoát bẫy đa cực trị.
    \item Các thuật toán còn lại (GA, HC, SA) hầu như không đạt được ngưỡng Bronze trong ngân sách đã chọn nên không xuất hiện trên đồ thị; về thực chất, chúng thất bại gần như hoàn toàn trên Rastrigin 30 chiều ở mức mục tiêu này.
    \item Ở mức Silver, độ khó tăng vọt: chỉ FA \emph{specialist} đạt được một phần nhỏ số lần chạy (ECDF dừng dưới \(0.3\) ngay cả ở rìa phải trục hoành), trong khi FA gốc và các thuật toán khác không có lần chạy nào chạm ngưỡng. Điều này cho thấy từ 30 chiều trở lên, mức Silver của Rastrigin đã vượt quá khả năng của hầu hết thuật toán trong bộ benchmark.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ecdf_scalability.png}
\caption{ECDF cho scalability (dim=50, trục log).}
\label{fig:rastrigin_ecdf_scale}
\end{figure}

Ở cấu hình 50 chiều, Rastrigin trở thành một bài toán đặc biệt thách thức trong bối cảnh ngân sách giới hạn:

\begin{itemize}[leftmargin=1.6em]
    \item Ở mức Bronze, chỉ còn FA \emph{specialist} đạt được một tỉ lệ thành công trung bình khá khiêm tốn: đường ECDF tăng rất chậm và chỉ tiệm cận quanh \(0.7\) khi ngân sách tiến gần \(4\times 10^4\) đánh giá. FA gốc và các thuật toán khác không đạt được ngưỡng nên không để lại dấu vết trên đồ thị.
    \item Ở mức Silver, toàn bộ các đường ECDF nằm tại 0, tương đương việc không thuật toán nào đạt được ngưỡng Silver trên Rastrigin 50 chiều trong ngân sách tối đa. Rastrigin high-dimensional với yêu cầu độ chính xác cao vì thế có thể xem là “ngoài tầm với” đối với tập thuật toán đang xét.
\end{itemize}

\paragraph{Fixed-Budget Performance: sai số cuối cùng dưới các mức ngân sách cố định.}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{picture/rastrigin_fixed_budget_quick_convergence.png}
\caption{Rastrigin – fixed-budget performance (quick\_convergence, $d=10$). Trục tung là sai số trung vị (median error), trục hoành là tỉ lệ ngân sách.}
\label{fig:rastrigin_budget_quick}
\end{figure}

Với cấu hình quick\_convergence (10 chiều), đường cong fixed-budget cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item Cả FA và GA đều có sai số trung vị giảm đơn điệu khi tăng ngân sách, nhưng FA luôn giữ mức sai số thấp hơn rõ rệt. Ở mọi mức budget (10\%, 30\%, 50\%, 100\%), đường của FA nằm dưới GA khoảng gần một bậc độ lớn trên thang log.
    \item Lợi ích của việc tăng ngân sách thể hiện mạnh giữa 10\% và 30\%; sau khoảng 50\% ngân sách, cả hai thuật toán đều rơi vào vùng “diminishing returns”, sai số giảm thêm rất ít.
    \item Cấu hình \emph{specialist} cải thiện nhẹ cho cả hai thuật toán, chủ yếu ở ngân sách nhỏ (10–30\%). Tuy nhiên, thứ hạng tương đối không đổi: FA vẫn là thuật toán cho sai số cuối cùng thấp nhất, GA ổn định nhưng kém hơn trên toàn dải ngân sách.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{picture/rastrigin_fixed_budget_multimodal_escape.png}
\caption{Rastrigin – fixed-budget performance (multimodal\_escape, $d=30$).}
\label{fig:rastrigin_budget_multimodal}
\end{figure}

Khi tăng lên cấu hình multimodal\_escape (30 chiều), độ khó tăng rõ rệt:

\begin{itemize}[leftmargin=1.6em]
    \item Mức sai số trung vị của cả FA và GA đều cao hơn đáng kể so với $d=10$, ngay cả ở 100\% ngân sách. Điều này phù hợp với ECDF: nhiều lần chạy không chạm được các target Silver dù đã dùng hết ngân sách.
    \item FA tiếp tục giữ lợi thế ổn định: ở mọi mức budget, đường cong của FA nằm thấp hơn GA, và khoảng cách giữa hai thuật toán vẫn tương đối lớn.
    \item Tinh chỉnh \emph{specialist} giúp FA giảm thêm vài đơn vị sai số trên toàn dải ngân sách, trong khi GA cũng cải thiện nhưng vẫn bị bỏ xa. Có thể hiểu rằng ở 30 chiều, FA không chỉ đạt tỉ lệ thành công cao hơn (ECDF) mà còn cho chất lượng nghiệm cuối cùng tốt hơn trong khung fixed-budget.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{picture/rastrigin_fixed_budget_scalability.png}
\caption{Rastrigin – fixed-budget performance (scalability, $d=50$).}
\label{fig:rastrigin_budget_scale}
\end{figure}

Ở cấu hình scalability (50 chiều), bức tranh trở nên bi quan hơn:

\begin{itemize}[leftmargin=1.6em]
    \item Các đường cong cho thấy sai số trung vị vẫn rất cao ngay cả khi dùng 100\% ngân sách: FA chỉ giảm từ khoảng $\sim 1.7\times 10^2$ xuống dưới $10^2$, GA dao động quanh vùng $[1.8, 3]\times 10^2$. Điều này nhất quán với ECDF: gần như không có lần chạy nào đạt được các target Bronze/Silver ở 50 chiều.
    \item FA tiếp tục vượt trội GA trên toàn bộ dải budget: với cùng một ngân sách, nghiệm trung vị của FA luôn tốt hơn đáng kể. Nói cách khác, nếu buộc phải chọn giữa hai thuật toán trong bối cảnh high-dimensional Rastrigin, FA luôn là lựa chọn “ít tệ hơn”.
    \item Cấu hình \emph{specialist} giúp FA cải thiện thêm một chút (đặc biệt ở ngân sách thấp), nhưng không thay đổi bản chất vấn đề: với dimension 50 và ngân sách hiện tại, cả hai thuật toán đều đang hoạt động trong vùng “chưa hội tụ”, sai số tuyệt đối vẫn lớn so với nghiệm tối ưu.
\end{itemize}


\paragraph{ERT, performance profiles và data profiles.}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ert_bronze.png}
\caption{Rastrigin – ERT tới ngưỡng Bronze.}
\label{fig:rastrigin_ert_bronze}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ert_silver.png}
\caption{Rastrigin – ERT tới ngưỡng Silver.}
\label{fig:rastrigin_ert_silver}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_ert_gold.png}
\caption{Rastrigin – ERT tới ngưỡng Gold (không có thuật toán nào đạt target).}
\label{fig:rastrigin_ert_gold}
\end{figure}

ERT (Expected Running Time) chỉ có ý nghĩa khi tồn tại số lượng đủ lớn các lần chạy thành công trên target đang xét. Các biểu đồ ERT cho Rastrigin cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Ngưỡng Bronze.} Ở cấu hình \emph{quick\_convergence} (10 chiều), cả FA, GA và HC đều đạt được target Bronze. FA có ERT nhỏ nhất (cỡ $10^2$–$10^3$ đánh giá), GA chậm hơn khoảng một bậc, còn HC chậm hơn rất nhiều bậc và do đó chỉ đóng vai trò baseline. SA hầu như không đạt được target. Ở hai cấu hình khó hơn (\emph{multimodal\_escape} 30 chiều và \emph{scalability} 50 chiều), chỉ có FA đạt Bronze; các thuật toán còn lại không có run thành công nên không xuất hiện trên biểu đồ. Việc tinh chỉnh (\emph{specialist}) giúp ERT của FA giảm đáng kể nhưng giá trị tuyệt đối vẫn nằm trong vùng từ vài chục nghìn tới hàng triệu đánh giá.
    \item \textbf{Ngưỡng Silver.} Với Silver, bức tranh càng khắt khe hơn. Ở 10 chiều, FA và GA vẫn đạt target nhưng ERT của GA lớn hơn FA khá rõ, phản ánh việc GA cần nhiều đánh giá hơn để hội tụ tới mức sai số sâu hơn. Ở 30 chiều, chỉ còn FA (đặc biệt là cấu hình \emph{specialist}) đạt Silver với ERT rất lớn (khoảng $10^5$ đánh giá), và ở 50 chiều chỉ FA \emph{specialist} đạt Silver với ERT lên tới cỡ $10^6$. Điều này nhất quán với ECDF: Silver trên Rastrigin high-dimensional là một target cực khó.
    \item \textbf{Ngưỡng Gold.} Trên cả ba cấu hình và bốn thuật toán, không có run nào đạt được target Gold trong ngân sách cho phép. Vì vậy Hình~\ref{fig:rastrigin_ert_gold} thực chất minh hoạ một trường hợp “ERT không xác định”: success rate bằng 0, và mọi so sánh ERT tại ngưỡng Gold đều vô nghĩa.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{picture/rastrigin_perf_profile.png}
\caption{Performance profiles cho Rastrigin (Dolan–Moré).}
\label{fig:rastrigin_perf_profile}
\end{figure}

Performance profile mô tả, với mỗi tỷ lệ hiệu năng $\tau$, tỷ lệ các bài toán mà một thuật toán có thời gian chạy không vượt quá $\tau$ lần solver tốt nhất. Kết quả cho Rastrigin cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item Đường cong của FA nằm cao hơn GA tại $\tau = 1$, tức là trong số rất ít các cặp (cấu hình, target) được giải thành công, FA thường là thuật toán nhanh nhất về số lần đánh giá.
    \item Khi tăng $\tau$ lên khoảng 3, đường của GA mới bắt kịp FA; hai đường đều tiệm cận một mức trần thấp (khoảng $0{,}1$), phản ánh thực tế là chỉ một phần rất nhỏ các bài toán trong bộ test được giải bởi bất kỳ thuật toán nào.
    \item HC và SA hầu như không xuất hiện trên performance profile vì không giải được target nào trong tập Rastrigin ở các mức ngân sách đã chọn.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{picture/rastrigin_data_profile.png}
\caption{Data profiles cho Rastrigin (Moré–Wild).}
\label{fig:rastrigin_data_profile}
\end{figure}

Data profile $\psi(\nu)$ biểu diễn tỷ lệ bài toán được giải trong một ngân sách chuẩn hoá $\nu$ cho trước. Trên Rastrigin:

\begin{itemize}[leftmargin=1.6em]
    \item FA luôn là thuật toán có coverage cao nhất: với ngân sách rất nhỏ (vài trăm đánh giá), FA đã giải được khoảng $1/6$ số bài toán; khi tăng ngân sách lên cỡ $10^4$–$3\times10^4$ đánh giá, coverage tăng dần lên gần $2/3$.
    \item GA chỉ bắt đầu giải được bài toán khi ngân sách tăng lên mức trung bình và nhanh chóng đạt trần quanh mức $1/3$ số bài toán; sau đó đường cong của GA hầu như phẳng, không hưởng lợi nhiều từ việc tăng ngân sách.
    \item HC và SA không giải được bất kỳ instance nào trong bộ target Rastrigin dưới các mức ngân sách đã xét, nên đường data profile gần như dính sát trục hoành.
    \item Ngay cả ở ngân sách lớn nhất, không có thuật toán nào đạt coverage gần 1; điều này củng cố nhận định rằng Rastrigin high-dimensional (đặc biệt với các target Silver/Gold) về cơ bản là quá khó trong khung ngân sách hiện tại.
\end{itemize}

\subsubsection{Rastrigin: đa dạng quần thể và hiện tượng dừng sớm (stagnation)}

\paragraph{Đa dạng quần thể theo thời gian.}

Đa dạng quần thể được đo bằng khoảng cách Euclid trung bình giữa các cá thể, chuẩn hoá theo \(\sqrt{D}\) để cho phép so sánh giữa các chiều khác nhau.  
Hình~\ref{fig:rastrigin_diversity_quick}–\ref{fig:rastrigin_diversity_scale} hiển thị boxplot của bốn thời điểm:
\emph{initial} (ngay sau khởi tạo), \emph{mid} (50\% ngân sách), \emph{final} (kết thúc chạy) và \emph{drop} (mức giảm đa dạng từ initial tới final).

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_diversity_quick_convergence.png}
\caption{Rastrigin – phân tích đa dạng quần thể (quick\_convergence, \(D=10\)).}
\label{fig:rastrigin_diversity_quick}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_diversity_multimodal_escape.png}
\caption{Rastrigin – phân tích đa dạng quần thể (multimodal\_escape, \(D=30\)).}
\label{fig:rastrigin_diversity_multimodal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_diversity_scalability.png}
\caption{Rastrigin – phân tích đa dạng quần thể (scalability, \(D=50\)).}
\label{fig:rastrigin_diversity_scale}
\end{figure}

Các quan sát chính:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Khởi tạo.}  
    Trên cả ba cấu hình, FA và GA đều bắt đầu với mức đa dạng khá cao (\(\approx 2{,}0\)–\(2{,}8\) sau chuẩn hoá).  
    Với cấu hình quick\_convergence, GA (đặc biệt bản out-of-the-box) có đa dạng khởi tạo lớn hơn FA, trong khi FA \emph{specialist} có mức cao nhất.  
    Điều này cho thấy lợi thế của FA trên Rastrigin không đến từ việc “rải quần thể rộng hơn ngay từ đầu” mà chủ yếu do động lực cập nhật trong quá trình tối ưu.
    
    \item \textbf{Giữa quá trình (50\% ngân sách).}  
    Ở cả ba cấu hình, GA mất đa dạng rất nhanh: median diversity của GA chỉ còn \(\approx 0{,}01\)–\(0{,}02\), trong khi FA vẫn duy trì quanh \(\approx 0{,}06\)–\(0{,}10\).  
    FA \emph{specialist} có đa dạng mid hơi thấp hơn FA gốc nhưng vẫn cao hơn GA rõ rệt.  
    Tức là GA trải qua hiện tượng \emph{premature convergence}: áp lực chọn lọc và lai ghép làm quần thể co cụm sớm quanh một vài basin, trong khi FA vẫn giữ được một “vòng đai” nghiệm khác biệt hơn.
    
    \item \textbf{Cuối quá trình.}  
    Tới thời điểm kết thúc, đa dạng của GA gần như bằng 0 ở mọi cấu hình, cho thấy quần thể gần như đồng nhất.  
    FA vẫn giữ một mức đa dạng dương đáng kể (đặc biệt ở multimodal\_escape và scalability), dù đã giảm hơn 90\% so với ban đầu.  
    Điều này phù hợp với quan sát ECDF: FA vẫn còn khả năng “nhúc nhích” sang các basin khác ở cuối run, trong khi GA gần như bị khoá cứng trong một vùng nghiệm.
    
    \item \textbf{Mức giảm đa dạng (drop).}  
    Cả FA và GA đều có \emph{drop} lớn (trên 90\% initial diversity), riêng GA thường tụt về gần 0 nên drop tuyệt đối của GA thường lớn hơn hoặc tương đương FA.  
    FA \emph{specialist} có drop lớn nhất trên quick\_convergence do khởi tạo rất rộng, nhưng vẫn duy trì đa dạng mid/final cao hơn GA – tức là FA tuned vừa mở rộng được phạm vi tìm kiếm ban đầu vừa không suy sụp quá nhanh.
    
    \item \textbf{HC và SA.}  
    HC và SA làm việc với một quỹ đạo đơn (population size = 1), nên chỉ số đa dạng về mặt định nghĩa luôn bằng 0.  
    Việc hai thuật toán này thất bại trên Rastrigin high-dimensional vì vậy không liên quan tới “quản lý đa dạng” mà nằm ở cơ chế bước nhảy và tiêu chí chấp nhận (đã được phản ánh ở ECDF và ERT).
\end{itemize}

Tóm lại, trên các bài toán Rastrigin khó, FA không hề “giữ đa dạng tốt” theo nghĩa tuyệt đối – quần thể của nó cũng co cụm mạnh. Tuy nhiên, so với GA, FA duy trì được một mức lan trải vừa đủ ở giai đoạn giữa và cuối quá trình, đủ để sinh ra một số lời giải thoát khỏi bẫy địa phương. GA lại đánh mất đa dạng quá sớm, dẫn tới trạng thái tìm kiếm gần như gradient-free quanh một cực trị trung bình.

\paragraph{Phân tích stagnation.}

Để làm rõ hơn mối liên hệ giữa đa dạng và khả năng thoát bẫy, ta xem xét \emph{độ dài stagnation}: số thế hệ liên tiếp mà giá trị tốt nhất toàn cục không được cải thiện. Với mỗi run, ta lấy đoạn stagnation dài nhất.  
Hình~\ref{fig:rastrigin_stagnation_quick}–\ref{fig:rastrigin_stagnation_scale} trình bày phân bố độ dài này (histogram) và ECDF tương ứng cho FA và GA.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_stagnation_quick_convergence.png}
\caption{Rastrigin – phân tích stagnation (quick\_convergence, \(D=10\)).}
\label{fig:rastrigin_stagnation_quick}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_stagnation_multimodal_escape.png}
\caption{Rastrigin – phân tích stagnation (multimodal\_escape, \(D=30\)).}
\label{fig:rastrigin_stagnation_multimodal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{picture/rastrigin_stagnation_scalability.png}
\caption{Rastrigin – phân tích stagnation (scalability, \(D=50\)).}
\label{fig:rastrigin_stagnation_scale}
\end{figure}

Các kết quả cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Quick\_convergence (10 chiều).}  
    Cả FA và GA đều có độ dài stagnation trung bình vào khoảng 100–160 thế hệ, phản ánh việc bài toán tương đối dễ: cả hai thuật toán vẫn tiếp tục tạo thêm cải thiện nhỏ cho tới gần cuối run.  
    Đường ECDF của GA nằm hơi lệch sang trái so với FA, tức GA thường có đoạn stagnation dài nhất ngắn hơn một chút. Điều này phù hợp với fixed-budget plot: GA khai thác rất mạnh trong vùng lân cận nghiệm hiện tại và liên tục tạo ra cải thiện nhỏ, nhưng vẫn không đạt được sai số thấp như FA.
    
    \item \textbf{Multimodal\_escape (30 chiều).}  
    Khi dimension tăng, tương quan đảo chiều. Histogram và ECDF cho thấy GA thường có đoạn stagnation dài hơn: nhiều run của GA có stagnation vượt quá 300 thế hệ, trong khi phần lớn run của FA dừng dưới khoảng 220–240 thế hệ.  
    Nghĩa là trên landscape đa cực trị phức tạp hơn, GA dễ bị “đóng băng” trong một basin: quần thể đã đồng nhất (đa dạng gần 0) nhưng cơ chế đột biến / lai ghép không đủ mạnh để tạo ra bước nhảy mang tính phá vỡ.
    
    \item \textbf{Scalability (50 chiều).}  
    Ở cấu hình khó nhất, sự chênh lệch càng rõ: ECDF của FA nằm cao hơn GA trên toàn trục hoành. Khoảng 70–80\% run của FA có đoạn stagnation dài nhất dưới 200 thế hệ, trong khi GA phải tới khoảng 300–350 thế hệ mới đạt mức ECDF tương đương.  
    Điều này khớp với ERT và ECDF fixed-target: FA dù vẫn thất bại trên nhiều run nhưng vẫn tạo được một số cải thiện muộn (late improvements), còn GA gần như bị “lock” trong vùng nghiệm kém trong phần lớn thời gian chạy.
\end{itemize}


\subsubsection{Knapsack: hiệu năng fixed-budget (gap tới nghiệm tối ưu)}

Trong bài toán Knapsack, ta dùng thước đo \emph{Gap to Optimal} (\%) sau khi tiêu tốn một tỉ lệ cố định của ngân sách đánh giá (10\%, 30\%, 50\% và 100\%).  
Gap được định nghĩa ở Mục~\ref{subsec:Chi_so_danh_gia}{;} giá trị nhỏ hơn là tốt hơn, và các giá trị quanh \(200\%\) tương ứng với việc thuật toán chỉ đạt được khoảng một nửa giá trị tối ưu.

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_fixed_budget_Gap_10pct.png}
\caption{Knapsack – fixed-budget gap tại 10\% ngân sách cho ba kích thước bài toán \(N \in \{50, 100, 200\}\).}
\label{fig:knapsack_fb_10}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_fixed_budget_Gap_30pct.png}
\caption{Knapsack – fixed-budget gap tại 30\% ngân sách.}
\label{fig:knapsack_fb_30}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_fixed_budget_Gap_50pct.png}
\caption{Knapsack – fixed-budget gap tại 50\% ngân sách.}
\label{fig:knapsack_fb_50}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_fixed_budget_Gap_100pct.png}
\caption{Knapsack – fixed-budget gap tại 100\% ngân sách.}
\label{fig:knapsack_fb_100}
\end{figure}

Các kết quả này cho thấy một bức tranh rất khác so với Rastrigin:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Mức độ khó tổng thể.}  
    Ở mọi cấu hình, median gap của bốn thuật toán đều nằm trong dải \(190\%{-}200\%\). Điều này cho thấy các metaheuristic đang làm việc trong một landscape tổ hợp rất khó: lời giải thu được thường chỉ đạt xấp xỉ một nửa giá trị tối ưu.  
    Việc tăng ngân sách từ 10\% lên 100\% chỉ giúp giảm gap thêm một vài đơn vị phần trăm, nghĩa là phần lớn lợi ích đã được “ăn” trong giai đoạn rất sớm; ngân sách còn lại chủ yếu làm thu hẹp phương sai giữa các lần chạy và kéo dài đuôi dưới.

    \item \textbf{Xếp hạng giữa các thuật toán.}  
    Thứ hạng tương đối giữa bốn thuật toán khá ổn định trên mọi \(N\) và mọi mức ngân sách:
    \begin{itemize}
        \item \textbf{FA tệ nhất một cách ổn định.}  
        Boxplot của FA gần như “dính” ở vùng gap xấp xỉ \(200\%\) với phương sai rất nhỏ, gần như không có đuôi dưới. FA hội tụ nhanh vào một vùng nghiệm kém và hầu như không cải thiện thêm khi tăng ngân sách.
        \item \textbf{GA cho chất lượng điển hình tốt nhất.}  
        Trong hầu hết các panel, GA có median gap thấp nhất (hoặc ngang ngửa SA nhưng ổn định hơn), phân bố tập trung hơn quanh giá trị \(\approx 190\%\). GA rõ ràng là thuật toán cho “chất lượng trung bình” tốt nhất trên Knapsack trong bộ thực nghiệm này.
        \item \textbf{SA có những lời giải tốt nhất nhưng hiếm.}  
        Median của SA thường nhỉnh hơn GA một chút, nhưng SA là thuật toán duy nhất có đuôi dưới kéo dài xuống vùng \(150\%{-}170\%\), thể hiện một số run hiếm hoi tìm được lời giải tốt vượt trội so với phần còn lại. Nói cách khác, SA không phải là tốt nhất về mặt điển hình, nhưng lại có tiềm năng sinh ra những nghiệm rất tốt khi “gặp may”.
        \item \textbf{HC nằm giữa GA và FA.}  
        HC có median thấp hơn FA nhưng cao hơn GA và thường không chạm được tới những nghiệm rất tốt như SA. Phân bố của HC dày đặc quanh một vùng gap cố định, cho thấy một chiến lược khai thác địa phương tương đối hiệu quả nhưng thiếu các bước nhảy đủ xa để tạo ra những lời giải đột phá.
    \end{itemize}
    
    \item \textbf{Ảnh hưởng của kích thước bài toán.}  
    Khi tăng số lượng vật phẩm từ \(N=50\) lên \(N=200\), median gap của từng thuật toán chỉ dao động nhẹ quanh ngưỡng \(190\%{-}200\%\), và thứ hạng tương đối hầu như không thay đổi. Độ khó mà các thuật toán đang gặp phải vì vậy có vẻ đến từ \emph{cấu trúc} instance và cơ chế cập nhật hơn là riêng yếu tố số biến. Ở mọi \(N\), SA vẫn là thuật toán duy nhất có đuôi dưới rất sâu, GA vẫn giữ median thấp nhất, trong khi FA luôn nằm sát phía trên.
    
    \item \textbf{Ảnh hưởng của ngân sách.}  
    So sánh bốn mức ngân sách cho thấy:
    \begin{itemize}
        \item FA hầu như không phản ứng với việc tăng ngân sách – median và phương sai gần như bất biến. Đây là dấu hiệu của \emph{stagnation triệt để}: thêm đánh giá chỉ lặp lại các bước nhảy quanh một vùng nghiệm tệ.
        \item GA, HC và đặc biệt là SA có cải thiện chủ yếu ở phần tail: khi ngân sách tăng, số lượng run đạt được gap tốt (đuôi dưới) tăng lên, nhưng median chỉ nhích xuống rất nhẹ. Các thuật toán này do đó phụ thuộc khá nhiều vào một số run “may mắn”; để cải thiện một cách đáng tin cậy hơn, cần hoặc ngân sách lớn hơn đáng kể, hoặc các chiến lược đa khởi tạo / tái khởi tạo rõ ràng.
    \end{itemize}
\end{itemize}


\vspace{0.5em}

\subsubsection{Knapsack: performance/data profiles và so sánh thống kê}

%----------------- HÌNH CHO 1.6.4 -----------------

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_data_profiles.png}
\caption{Data profile Moré--Wild cho Knapsack.}
\label{fig:knapsack_data_profile}
\end{figure}

Đối với Knapsack, data profile Moré--Wild $\psi(\nu)$ trong Hình~\ref{fig:knapsack_data_profile} không còn suy biến như trường hợp Rastrigin.  
Với tập target được chọn, FA đạt giá trị $\psi(\nu)$ cao nhất trên toàn dải ngân sách: ngay từ $\nu \approx 10^2$ đã giải được hơn một nửa số cặp (bài toán, target), và khi $\nu$ tiến tới $10^4$ thì đường của FA gần như chạm tới 1.  
HC đứng thứ hai với mức phủ khoảng $0.8$, trong khi GA và SA dừng lại quanh $0.6{-}0.65$.  
Nói cách khác, dưới một định nghĩa thành công khá “thoáng” (gap tới tối ưu không cần quá nhỏ), FA là thuật toán có xác suất cao nhất đưa nghiệm vào vùng “chấp nhận được” trong ngân sách cho trước; HC theo sau, còn GA và SA chậm hơn đáng kể.  
Tuy nhiên, các ngưỡng target này vẫn tương đối xa tối ưu, nên data profile phản ánh chủ yếu khả năng đạt \emph{xấp xỉ thô} hơn là khả năng tiệm cận nghiệm tối ưu thực sự.

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_performance_profiles.png}
\caption{Performance profile Dolan--Moré cho Knapsack, dùng số phép đánh giá để đạt target làm metric.}
\label{fig:knapsack_perf_profile}
\end{figure}

Performance profile Dolan--Moré trong Hình~\ref{fig:knapsack_perf_profile} củng cố bức tranh đó.  
Đường $\varphi(\tau)$ của FA nằm rất cao ngay từ những giá trị $\tau$ nhỏ: với một hệ số hiệu năng khiêm tốn, FA đã giải được gần như toàn bộ các cặp (bài toán, target) nhanh nhất hoặc gần nhanh nhất trong tập thuật toán.  
Ba thuật toán còn lại chỉ dần bắt kịp khi $\tau$ tăng lên vài bậc độ lớn, cho thấy chúng thường cần nhiều phép đánh giá hơn FA để đạt cùng một target “dễ”.  
Giữa ba baseline, HC và SA nhìn chung nằm phía trên GA trong phần lớn dải $\tau$, tức là về tốc độ đạt target thô thì GA thậm chí còn kém cạnh hơn.  

Quan trọng là, cũng như với data profile, performance profile ở đây hoàn toàn \emph{tương đối}: metric được chuẩn hoá theo thuật toán tốt nhất trên từng cặp (bài toán, target), và target lại là các ngưỡng gap khá lỏng.  
Vì vậy, việc FA “thống trị” Hình~\ref{fig:knapsack_perf_profile} chỉ nói rằng FA hiếm khi tệ nhất và rất ổn định trong việc đạt một mức xấp xỉ tương đối, chứ không hề phủ định kết luận từ các biểu đồ fixed-budget rằng nghiệm cuối của FA vẫn cách rất xa tối ưu.

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_pairwise_heatmap_overall.png}
\caption{Heatmap số lần thắng--thua có ý nghĩa thống kê giữa các cặp thuật toán trên toàn bộ nghiệm cuối.}
\label{fig:knapsack_pairwise_overall}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_copeland_ranking.png}
\caption{Điểm Copeland (thắng trừ thua) cho từng thuật toán Knapsack.}
\label{fig:knapsack_copeland}
\end{figure}

Để có một bức tranh cân bằng hơn, chúng tôi dựa vào so sánh thống kê cặp đôi và điểm Copeland.  
Hình~\ref{fig:knapsack_pairwise_overall} cho thấy mọi thuật toán còn lại đều áp đảo FA: GA thắng FA 72 lần có ý nghĩa thống kê, HC thắng 58 lần và SA thắng 62 lần, trong khi FA chỉ thắng được HC đúng 3 lần và không có trận thắng nào trước GA hoặc SA.  
Giữa ba thuật toán GA, HC và SA, cán cân nghiêng rõ về phía SA: SA thắng GA 39 lần trong khi GA chỉ thắng SA 21 lần; SA thắng HC 52 lần và HC hoàn toàn không có trận thắng đáng kể nào trước SA.  
GA lại thắng HC 55 lần so với 6 lần ngược lại, nên xét theo đối đầu trực tiếp, trật tự ưu thế tổng quát là SA $>$ GA $>$ HC $>$ FA.  

Điểm Copeland trong Hình~\ref{fig:knapsack_copeland} tóm tắt gọn các quan sát này: SA đạt $+132$ điểm, GA đạt $+103$, HC ở mức $-46$ và FA rơi xuống $-189$.  
Như vậy, dù FA trông rất “đẹp” dưới lăng kính data/performance profile, khi đánh giá bằng số trận thắng--thua có ý nghĩa thống kê trên toàn bộ tập nghiệm thì SA vẫn là thuật toán chiếm ưu thế rõ rệt nhất, GA là đối thủ cạnh tranh trực tiếp, HC là trung bình và FA là lựa chọn kém nhất.

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_pairwise_heatmap_penalty.png}
\caption{Heatmap thắng--thua khi chỉ xét chất lượng nghiệm penalty (trước pha repair).}
\label{fig:knapsack_pairwise_penalty}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.98\textwidth]{picture/knapsack_pairwise_heatmap_repair.png}
\caption{Heatmap thắng--thua khi chỉ xét chất lượng nghiệm sau pha repair.}
\label{fig:knapsack_pairwise_repair}
\end{figure}

Hai heatmap bổ sung trong Hình~\ref{fig:knapsack_pairwise_penalty} và~\ref{fig:knapsack_pairwise_repair} giúp tách riêng vai trò của pha penalty và pha repair.  
Ở mức penalty (trước khi repair), SA nổi bật nhất: SA thắng GA 28 lần và thắng HC 28 lần, trong khi GA không có trận thắng nào trước SA. GA vẫn thắng HC 22 lần so với 6 lần thua, và cả GA, HC, SA đều thắng FA 36 lần.  
Điều này gợi ý rằng quỹ đạo tìm kiếm của SA tạo ra nhiều nghiệm “thô” có giá trị mục tiêu rất tốt (dù còn vi phạm ràng buộc), GA đứng thứ hai, còn HC và đặc biệt là FA sinh ra các nghiệm penalty kém cạnh hơn nhiều.  

Sau pha repair (Hình~\ref{fig:knapsack_pairwise_repair}), bức tranh thay đổi phần nào. GA lúc này tương tác rất tốt với heuristic repair: GA thắng SA 21 lần, trong khi SA chỉ thắng GA 11 lần; GA cũng thắng HC 33 lần và thắng FA 36 lần. SA vẫn thắng HC 24 lần và thắng FA 26 lần, còn HC thắng FA 22 lần (FA chỉ gỡ gạc được 3 trận thắng trước HC).  
Nói cách khác, repair đã “bù đắp” một phần bất lợi ban đầu của GA, giúp GA tận dụng tốt các nghiệm penalty của mình để xây dựng nghiệm khả thi chất lượng cao, trong khi SA vẫn giữ được ưu thế nhưng không còn vượt trội tuyệt đối.

Kết hợp tất cả các lát cắt trên, bức tranh cuối cùng cho Knapsack là:  
FA tuy có data/profile rất đẹp nhờ ổn định và nhanh đạt target thô, nhưng về chất lượng nghiệm cuối và số lần thắng có ý nghĩa thống kê thì liên tục bị các thuật toán còn lại chi phối và có thể xem như một baseline đơn giản.  
HC cải thiện rõ rệt so với FA nhưng hiếm khi vượt được GA và SA.  
GA là đối thủ mạnh thứ hai: sau pha repair, GA cho chất lượng điển hình tốt nhất và thường xuyên thắng HC, đôi khi thua SA trên các instance khó.  
SA là thuật toán thể hiện tốt nhất về tổng thể, đặc biệt mạnh ở giai đoạn penalty và trong các so sánh cặp đôi, dẫn đến điểm Copeland cao nhất.  
Dù vậy, cả bốn thuật toán vẫn đang hoạt động trong vùng \emph{xấp xỉ thô}: các fixed-budget boxplot cho thấy gap tới nghiệm tối ưu còn rất lớn, nên mọi kết luận về Knapsack trong báo cáo này cần được hiểu là so sánh giữa các metaheuristic chưa hội tụ, chứ không phải giữa những thuật toán đã thực sự giải được bài toán tới gần mức tối ưu.

\vspace{0.5em}

\subsubsection{Thảo luận}

\paragraph{Rastrigin: giới hạn của bộ thuật toán trong bối cảnh high-dimensional.}

Khi đặt ERT và performance profiles cạnh ECDF và data profiles, bức tranh trở nên rõ ràng hơn rất nhiều: các tín hiệu “tốt” của GA và FA ở dimension thấp không kéo dài được sang dimension cao.

\begin{itemize}[leftmargin=1.6em]
    \item Ở 10 chiều, GA và FA giảm sai số cuối đáng kể so với HC và SA, nhưng tỷ lệ thành công cho các target khó vẫn không cao.
    \item Ở 30 và 50 chiều, cả bốn thuật toán gần như đồng loạt “chựng lại”: ECDF phẳng, data profiles có coverage rất thấp và đa phần các lần chạy dừng xa optimum.
    \item GA vẫn là lựa chọn tương đối tốt nhất trong bốn thuật toán, nhưng chỉ theo nghĩa tương đối. Xét giá trị tuyệt đối, không thuật toán nào tiệm cận mức “giải tốt Rastrigin high-dimensional” dưới ngân sách hiện hành.
\end{itemize}

Do đó, phần Rastrigin của benchmark không nhằm tìm ra thuật toán “giải trọn” bài toán, mà nhằm minh hoạ giới hạn vận hành của bốn heuristic này khi dimensionality tăng và ngân sách hạn chế.

\paragraph{Firefly Algorithm trên Rastrigin: tác động của độ suy giảm hấp dẫn.}

FA trên không gian continuous high-dimensional gặp điểm nghẽn quen thuộc:

\[
\beta(r) = \beta_0 \exp(-\gamma r^2).
\]

Khoảng cách điển hình trong không gian $d$ chiều tăng theo $\sqrt{d}$; vì vậy nếu $\gamma$ không được giảm mạnh theo $d$, thì $\beta(r)$ gần như bị triệt tiêu. Điều này đúng trong toàn bộ thí nghiệm:

\begin{itemize}[leftmargin=1.6em]
    \item Dù đã giảm $\gamma$ theo dimension, mức giảm vẫn không đủ để giữ tương tác giữa các cá thể.
    \item Khi $\beta(r)$ nhỏ, FA thoái hoá thành một dạng random walk có nhiễu: di chuyển nhiều nhưng không “hút” nhau, dẫn tới không thể chui sâu vào basin tốt trong thời gian hữu hạn.
\end{itemize}

Điểm này gợi ý rằng muốn FA cạnh tranh được trên continuous high-dimensional, cần cơ chế điều chỉnh $\gamma$ và $\alpha$ theo thời gian hoặc theo phân bố quần thể thay vì giữ cố định.

\paragraph{Knapsack: sức mạnh của FA rời rạc kết hợp repair heuristic.}

Trên Knapsack, tình thế đảo chiều hoàn toàn. FA rời rạc thể hiện rất mạnh do đúng cấu trúc bài toán:

\begin{itemize}[leftmargin=1.6em]
    \item Cơ chế lật bit có hướng giống local search có định hướng, vốn thích hợp với không gian 0/1.
    \item Greedy repair theo tỷ số $v_k / w_k$ không chỉ khôi phục feasibility mà còn tăng giá trị mục tiêu, khiến mỗi bước repair giống như một bước tối ưu hoá cục bộ.
    \item Toàn bộ pipeline (bit-flip định hướng + nhiễu nhỏ + repair tham lam) tạo ra phân bố gap nhỏ hơn đáng kể, được xác nhận lại qua performance/data profiles và thống kê (Wilcoxon + Copeland).
\end{itemize}

Kết luận không phải “FA luôn tốt hơn GA”, mà là: \emph{trong biến thể rời rạc hiện tại}, FA đặc biệt phù hợp với cấu trúc Knapsack 0/1 — và điều này hiển thị rất rõ qua mọi chỉ số.

\paragraph{Ý nghĩa và hạn chế của performance/data profiles khi success rate thấp.}

Dolan–Moré performance profile và Moré–Wild data profile là công cụ so sánh mạnh, nhưng dễ gây ảo giác nếu success rate thấp:

\begin{itemize}[leftmargin=1.6em]
    \item Performance profile chỉ xét những run đạt target $\Rightarrow$ thuật toán có ít run thành công vẫn có thể “đẹp”.
    \item Data profile phản ánh coverage tốt hơn nhưng phụ thuộc mạnh vào target và ngân sách.
\end{itemize}

Trong báo cáo này:

\begin{itemize}[leftmargin=1.6em]
    \item Rastrigin high-dimensional: GA và FA trông đẹp trên performance profile, nhưng ECDF và data profile cho thấy coverage thấp.
    \item Knapsack: tất cả đồ thị đều kể cùng một câu chuyện — FA vượt trội GA/HC/SA một cách nhất quán.
\end{itemize}

\paragraph{Không có thuật toán tối ưu “mọi nơi”: liên hệ với No Free Lunch.}

Ngay trong hai bài toán của benchmark, tính “không miễn phí” thể hiện rõ:

\begin{itemize}[leftmargin=1.6em]
    \item GA mạnh hơn FA/HC/SA trên Rastrigin continuous (đặc biệt 10D).
    \item FA rời rạc + repair mạnh hơn GA/HC/SA trên Knapsack 0/1.
    \item HC và SA hiếm khi đứng đầu, nhưng là baseline quan trọng để đánh giá mặt bằng độ khó.
\end{itemize}

Điểm cốt lõi: \emph{hiệu năng phụ thuộc bài toán}, không có solver nào thống trị toàn bộ.

\paragraph{Bài học về thiết kế benchmark và cách diễn giải kết quả.}

Một số kinh nghiệm rút ra từ quá trình xây dựng pipeline:

\begin{itemize}[leftmargin=1.6em]
    \item \textbf{Metric phải đúng:} nhầm hướng cực trị khiến performance/data profile phẳng hoàn toàn — bài học lớn nhất khi phân tích Rastrigin.
    \item \textbf{ERT phải đi cùng success rate:} nếu không, ERT trên target khó trở nên vô nghĩa.
    \item \textbf{Hyperparameter cố định theo kịch bản:} thiết kế này đảm bảo công bằng, nhưng chỉ đại diện cho “out-of-the-box baseline”, không phải hiệu năng tối ưu.
    \item \textbf{Kết luận phải phản ánh giới hạn:} báo cáo tốt phải dám chỉ ra nơi thuật toán thất bại thay vì chỉ nhấn mạnh điểm mạnh.
\end{itemize}

\paragraph{Tổng kết.}

Benchmark này cho thấy:

\begin{itemize}[leftmargin=1.6em]
    \item Trên Rastrigin, không thuật toán nào đạt mức giải strong khi dimension tăng; GA vẫn là lựa chọn tương đối tốt nhất trong bốn, nhưng chỉ theo nghĩa tương đối.
    \item Trên Knapsack, FA rời rạc kết hợp greedy repair vượt trội GA/HC/SA về gap, coverage và kết quả thống kê.
\end{itemize}

Giá trị của benchmark không nằm ở việc tìm một “người thắng tuyệt đối”, mà ở việc chỉ ra thuật toán nào phù hợp với cấu trúc nào, dưới ngân sách nào — và minh bạch về nơi mỗi thuật toán thất bại.


\subsection{Cuckoo Search}

