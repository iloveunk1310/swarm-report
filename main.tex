
\documentclass[11pt, a4paper]{article}
% --- Cấu hình trang ---
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath}  % Gói toán học
\usepackage{amssymb} % Gói ký hiệu toán học
\usepackage{algorithm}
\usepackage{algorithmic}
% --- Cấu hình tiếng Việt cho pdfLaTeX ---
\usepackage[utf8]{inputenc} % Cho phép file .tex lưu ở dạng UTF-8
\usepackage[T5]{fontenc}    % Sử dụng bộ mã T5 cho tiếng Việt
\usepackage[vietnamese]{babel} % Gói ngôn ngữ tiếng Việt
\usepackage{titlesec}
\titleclass{\subsubsubsection}{straight}[
\subsubsection]
\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\titleformat{\subsubsubsection}[runin]
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}[:]
\titlespacing*{\subsubsubsection}{0pt}{3.25ex plus 1ex minus .2ex}{1em}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{geometry}
\geometry{margin=1in}
% (Không cần gói 'fontspec' hoặc '\babelfont' nữa)
% Trình biên dịch sẽ dùng font LaTeX mặc định (Computer Modern)

% Sửa lỗi hiển thị bullet list (giữ nguyên)
\usepackage{enumitem}
\setlist[itemize]{label=-}

% Gói cho tiêu đề và liên kết
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Bao Cao Ant Colony Optimization},
    pdfauthor={Tac Gia},
    pdfsubject={ACO},
    pdfkeywords={ACO, AI, Optimization},
    bookmarks=true,
    breaklinks=true
}

% --- Tiêu đề tài liệu ---
\title{Báo cáo Đồ án: Tối ưu hóa Đàn kiến \\ (Ant Colony Optimization)}
\author{Tên Của Bạn} % <--- Thay tên của bạn ở đây
\date{\today}

% --- Bắt đầu tài liệu ---
\begin{document}

\maketitle
\tableofcontents
\newpage
\section*{Lời mở đầu}
\addcontentsline{toc}{section}{\protect\numberline{}Lời mở đầu}

\section{Giới thiệu chung}

\subsection{Thuật toán heuristic}

\subsection{Swarm intelligence algorithm}

\section{Ant Colony Optimization}
\subsection{Giới thiệu thuật toán}
Ant colony optimization (tối ưu hóa đàn kiến) là một thuật toán heuristic dựa trên ý tưởng về cách kiếm ăn của loài kiến, một loài sinh vật có ý thức bầy đàn rất cao và có khả năng phối hợp theo bầy rất hiệu quả cho các công việc như kiếm ăn, xây tổ,...

\subsubsection{Ý tưởng thuật toán}
Các nhà sinh vật học đã chỉ ra rằng một số loài kiến có khả năng tìm ra đường đi ngắn nhất giữa tổ và nguồn thức ăn. Chúng làm điều này dựa trên một cơ chế là stigmergy (liên lạc qua môi trường):
\begin{itemize}
    \item \textbf{Pheromone:} một tín hiệu hóa học do con đi trước thải ra, giúp con đi sau chọn đường có nồng độ cao hơn (con đường tốt hơn).
    \item Những con đi trên đường càng ngắn thì quay về tổ nhanh hơn. Con nào hoàn thành con đường nhanh hơn thì pheromone lưu lại càng nhiều trên con đường đó.
    \item \textbf{Autocatalytic (tự xúc tác):} nồng độ pheromone càng cao thì càng thu hút nhiều con kiến di chuyển trên đường đó, làm con đường càng tích lũy nhiều pheromone. Tới một lúc nào đó, toàn bộ đàn kiến sẽ hội tụ vào con đường ngắn nhất.
\end{itemize}

\subsubsection{Lịch sử thuật toán}
Nguồn gốc của ACO bắt nguồn từ các nghiên cứu về hành vi của côn trùng xã hội, đặc biệt là công trình của các nhà sinh vật học như Jean-Louis Deneubourg, người đã cung cấp cảm hứng cho công việc này.
\begin{itemize}
    \item \textbf{Những năm 1990:} Những nỗ lực đầu tiên nhằm chuyển hóa hành vi của kiến thành thuật toán máy tính xuất hiện vào đầu những năm 1990.
    \item \textbf{Ant System (AS):} Thuật toán ACO đầu tiên có tên là Ant System (AS). Nó được định nghĩa bởi Marco Dorigo trong luận án tiến sĩ của ông tại Politecnico di Milano (Ý), với sự hợp tác của Alberto Colorni và Vittorio Maniezzo.
    \item \textbf{1991-1996:} Bài báo chuyên san đầu tiên về Ant System được nộp vào năm 1991, nhưng phải đến năm 1996 mới được xuất bản. Nghiên cứu về ACO bắt đầu phổ biến và thu hút sự quan tâm nhanh chóng sau khi bài báo này ra đời.
    \item \textbf{Phát triển các biến thể:} Sau AS, một số biến thể thuật toán đã được phát triển để cải thiện hiệu suất, chẳng hạn như Ant-Q, Ant Colony System (ACS) và MAX-MIN AS.
    \item \textbf{Hình thành "Siêu heuristic ACO":} Thuật ngữ "ACO metaheuristic" (siêu heuristic ACO) đã được đề xuất (bởi Dorigo và Di Caro vào năm 1999) như một khung sườn chung (common framework) để bao quát các thuật toán và ứng dụng dựa trên cùng ý tưởng này.
\end{itemize}

\subsubsection{Những ứng dụng}
Thuật toán ACO là một thuật toán phổ biến và được ứng dụng rộng rãi nhờ tính linh hoạt và khả năng hội tụ tốt. Nó được ứng dụng nhiều trong các bài toán NP-hard (không thể tìm được đáp án chính xác trong thời gian đa thức):
\begin{itemize}
    \item Bài toán định tuyến: người giao hàng (TSP), sắp xếp thứ tự có ưu tiên (SOP),...
    \item Bài toán gán/ phân công: tô màu bản đồ (GCP), lập thời khóa biểu (UCTP),...
    \item Bài toán lập lịch
    \item Bài toán tập con: định tuyến mạng (thuật toán AntNet), bao phủ tập hợp (SCP),...
\end{itemize}

\subsection{Cơ sở toán học}
Cơ sở toán học của bài toán này có nhiều biến thể trên nhiều bài toán tối ưu hóa khác nhau, tuy nhiên chúng có điểm chung là cần được chuyển thành bài toán tìm đường đi ngắn nhất trong đồ thị có trọng số.

Cơ sở toán học của thuật toán Tối ưu hóa Đàn kiến (ACO) chủ yếu xoay quanh hai cơ chế: (1) quy tắc xác suất để kiến nhân tạo "xây dựng" giải pháp và (2) quy tắc cập nhật pheromone để "học hỏi" từ kinh nghiệm.

\subsubsection{Quy tắc Lựa chọn Đường đi (Xây dựng Giải pháp)}
Đây là công thức cốt lõi quyết định cách một con kiến nhân tạo $k$ chọn đỉnh tiếp theo khi nó đang ở đỉnh $i$. Xác suất $p_{ij}^k$ để kiến $k$ di chuyển từ đỉnh $i$ đến đỉnh $j$ là:

$$ p_{ij}^k = \frac{[\tau_{ij}]^\alpha [\eta_{ij}]^\beta}{\sum_{l \in \mathcal{N}_i^k} [\tau_{il}]^\alpha [\eta_{il}]^\beta} \quad \text{nếu } j \in \mathcal{N}_i^k $$

Trong đó:
\begin{itemize}
    \item \textbf{$\tau_{ij}$ (Pheromone):} Lượng pheromone nhân tạo trên cạnh nối $(i, j)$. Đây là thông tin "học được" (bộ nhớ dài hạn) về mức độ mong muốn của cạnh này.
    \item \textbf{$\eta_{ij}$ (Thông tin Heuristic):} Thông tin heuristic có sẵn (a priori) về cạnh $(i, j)$. Trong các bài toán tối ưu hóa, nó thường được định nghĩa là $1/c_{ij}$ (nghịch đảo của chi phí), nghĩa là cạnh có chi phí thấp sẽ hấp dẫn hơn.
    \item \textbf{$\alpha$ và $\beta$ (Tham số):} Hai tham số này kiểm soát tầm quan trọng tương đối của pheromone (kinh nghiệm đã học) so với thông tin heuristic (kiến thức có sẵn).
    \item \textbf{$\mathcal{N}_i^k$ (Tập lân cận khả thi):} Tập hợp các đỉnh mà kiến $k$ chưa đi qua (để đảm bảo tính hợp lệ của đường đi).
\end{itemize}

\subsubsection{Quy tắc Cập nhật Pheromone (Học tập)}
Sau khi tất cả $m$ con kiến đã hoàn thành việc xây dựng các đường đi, hệ thống sẽ cập nhật lượng pheromone. Quá trình này có hai phần: bay hơi và lắng đọng.

\textbf{Bay hơi Pheromone (Evaporation)}

Đầu tiên, một phần pheromone trên *tất cả* các cạnh sẽ "bay hơi" theo công thức:

$$ \tau_{ij} \leftarrow (1-\rho)\tau_{ij} $$

\begin{itemize}
    \item \textbf{$\rho$ (Hệ số bay hơi):} Một tham số $0 < \rho \le 1$.
    \item \textbf{Mục đích:} Cơ chế này giúp thuật toán "quên đi" các lựa chọn cũ, không tốt và tránh việc bị "kẹt" (stagnation) vô thời hạn tại một giải pháp dưới tối ưu.
\end{itemize}

\textbf{Lắng đọng Pheromone (Deposit)}

Tiếp theo, mỗi con kiến sẽ "lắng đọng" pheromone trên những cạnh mà nó đã đi qua, dựa trên chất lượng giải pháp (đường đi) mà nó tìm được.

Tổng lượng pheromone được thêm vào là:
$$ \tau_{ij} \leftarrow \tau_{ij} + \sum_{k=1}^m \Delta\tau_{ij}^k $$

Trong đó, $\Delta\tau_{ij}^k$ là lượng pheromone mà kiến $k$ lắng đọng lên cạnh $(i, j)$, được định nghĩa là:

$$ \Delta\tau_{ij}^k = \begin{cases} 1/C^k & \text{nếu cạnh } (i, j) \text{ thuộc đường đi } T^k \text{ của kiến } k \\ 0 & \text{nếu không} \end{cases} $$

\begin{itemize}
    \item \textbf{$C^k$ (Chất lượng giải pháp):} Là tổng chi phí của đường đi $T^k$ mà kiến $k$ đã thực hiện.
    \item \textbf{Ý nghĩa:} Một đường đi càng tốt (chi phí $C^k$ càng nhỏ) thì lượng pheromone $1/C^k$ lắng đọng trên các cạnh của nó càng lớn. Điều này làm tăng xác suất để các con kiến trong tương lai chọn lại những cạnh này.
\end{itemize}

\subsection{Triển khai thuật toán}
\subsubsection{Cách hoạt động của thuật toán}
\begin{algorithm}[h!]
\caption{Mã giả Siêu heuristic ACO}
\label{alg:aco_meta}
\begin{algorithmic}[1]
    \WHILE{chưa đạt điều kiện dừng}
        \FOR{số\_kiến}
        \STATE tạo\_giải\_pháp()
        \ENDFOR
        \STATE so\_sánh\_giải\_pháp()
        \STATE cập\_nhật\_hệ\_số\_pheromone()
    \ENDWHILE
    \RETURN giải pháp tốt nhất
\end{algorithmic}
\end{algorithm}
% --- KẾT THÚC SỬA LỖI ---

Chi tiết quá trình:
\begin{enumerate}
    \item Ở bước đầu tiên, mỗi “con kiến” sẽ chọn đường đi cho mình sao cho thỏa mãn đề bài. Để chọn được cạnh để đi trong mỗi bước, con kiến đó sẽ dựa vào mức độ pheromone của mỗi cạnh mà nó có thể đi và chọn ngẫu nhiên có trọng số trong các cạnh khả dĩ đó (theo công thức trong 2.1).
    \item Ở bước thứ 2, các giải pháp sẽ được so sánh với nhau, và giải pháp tốt nhất (tất nhiên so với cả các giải pháp ở vòng lặp trước) sẽ được chọn. Nếu đó là vòng lặp cuối cùng, giải pháp đó sẽ là kết quả của thuật toán.
    \item Ở bước tiếp theo, hệ số pheromone sẽ được cập nhật trên từng cạnh của đường đi (theo công thức trong 2.2). Hệ quả là, con đường nào càng ngắn thì các cạnh trên con đường đó sẽ lưu lại càng nhiều pheromone, dẫn đến xác suất chọn cạnh đó trong những lần sau sẽ cao hơn.
\end{enumerate}

Quá trình trên được lặp lại với số vòng lặp nhất định (từ 200-500 tùy vào số cạnh của đồ thị), hoặc cho tới khi hội tụ.

Một cách trực quan, quá trình này hội tụ về các chu trình ngắn bởi vì mỗi con kiến để lại càng nhiều pheromone trên các cạnh thuộc chu trình của nó nếu chu trình đó càng ngắn. Và, khi pheromone cũ mờ dần theo thời gian, đồng thời các con kiến mới ưu tiên những cạnh có nhiều pheromone hơn, thì các chu trình mới sẽ có xu hướng ngày càng ngắn hơn.

Điều quan trọng là, vì mỗi con kiến chọn bước đi tiếp theo một cách ngẫu nhiên, nên mặc dù chúng sẽ luôn có xu hướng chọn các ứng cử viên có nhiều pheromone nhất, chúng cũng sẽ có một xác suất đáng kể (không thể bỏ qua) để chọn một cạnh khác và đi khám phá. Nếu việc khám phá đó dẫn đến một chu trình tổng thể tốt hơn, con kiến đó sẽ "báo" cho các con kiến tương lai về chu trình này bằng cách để lại nhiều pheromone hơn nữa.

\subsubsection{Triển khai kỹ thuật}
\begin{itemize}
    \item Ngôn ngữ: Python
    \item Các thư viện sử dụng: numpy, random, matplotlib
    \item Các class:
    \begin{itemize}
        \item Class ACO\_Solver: chứa các hàm chính để giải bài toán và kiểm thử trên tập dữ liệu cho trước.
        \item Class Graph: cấu trúc đồ thị dưới dạng ma trận khoảng cách.
    \end{itemize}
    \item Chi tiết triển khai ở \texttt{github repository} (nằm trong phần phụ lục).
\end{itemize}

\section{Particle swarm optimization}
\subsection{Giới thiệu thuật toán}

Particle swarm optimization (tối ưu hóa bầy đàn) là một thuật toán heuristic mạnh mẽ được lấy cảm hứng bởi hành vi bầy đàn được quan sát trong tự nhiên như đàn cá và chim. PSO là một mô phỏng của một hệ thống xã hội được đơn giản hóa.

\subsubsection{Ý tưởng thuật toán}
Ý đồ của thuật toán PSO là mô phỏng lại cách di chuyển phức tạp của đàn chim. Trong tự nhiên, tầm nhìn của một con chim đơn lẻ là bị giới hạn. Tuy nhiên, có nhiều hơn một con chim cho phép đàn chim ý thức được vị trí của chúng trên một không gian rộng lớn hơn.

Không gian tìm kiếm thức ăn lúc này là toàn bộ không gian ba chiều.
Tại thời điểm bắt đầu tìm kiếm cả đàn bay theo một hướng thường là ngẫu nhiên.. Tuy nhiên sau một thời gian tìm kiếm một số cá thể trong đàn bắt đầu tìm ra được nơi có chứa thức ăn. 

Tùy theo số lượng thức ăn vừa tìm kiếm, mà cá thể gửi tín hiệu đến các các cá thể khác đang tìm kiếm ở vùng lân cận. Tín hiệu này lan truyền trên toàn quần thể. 

Dựa vào thông tin nhận được mỗi cá thể sẽ điều chỉnh hướng bay và vận tốc theo hướng về nơi có nhiều thức ăn nhất. 

Cơ chế truyền tin như vậy thường được xem như là một kiểu hình của trí tuệ bầy đàn. Cơ chế này giúp cả đàn chim tìm ra nơi có nhiều thức ăn nhất trên không gian tìm kiếm vô cùng rộng lớn.

\subsubsection{Lịch sử thuật toán}
Nghiên cứu sớm về ứng dụng tập tính bầy đàn trong thuật toán là mô hình "Boids" của Craig Reynolds. Reynolds đã chỉ ra rằng hành vi bầy đàn phức tạp có thể được mô phỏng chỉ bằng ba quy tắc đơn giản mà mỗi cá thể tuân theo (tách biệt, thẳng hàng, và gắn kết).

Thuật toán PSO được giới thiệu lần đầu tiên vào năm 1995 bởi hai nhà nghiên cứu: James Kennedy và Russell Eberhart, dựa trên công trình của Reynolds. PSO nhanh chóng trở nên phổ biến vì nó đơn giản hơn đáng kể so với các thuật toán tiến hóa khác như Giải thuật Di truyền (Genetic Algorithms - GA).

\subsubsection{Những ứng dụng}
Thuật toán PSO được ứng dụng rộng rãi trong nhiều lĩnh vực nhờ độ hiệu quả, tính đơn giản và linh hoạt của nó. Nó được ứng dụng trong nhiều lĩnh vực khác nhau:
\begin{itemize}
    \item Chăm sóc sức khỏe: Chẩn đoán thông minh, Phát hiện và phân loại bệnh, Phân đoạn hình ảnh y tế,...
    \item Môi trường: Giám sát chất lượng nước, giám sát lũ lụt,...
    \item Công nghiệp: Điều phối sản lượng điện (economic dispatch), Lập lịch tải điện, Tối ưu hóa Lưới điện thông minh,...
    \item Thương mại: Dự đoán chi phí và giá cả, đánh giá rủi ro,...
\end{itemize}

\subsection{Cơ sở toán học của thuật toán}
Cơ sở toán học của thuật toán PSO được thể hiện qua hai phương trình cốt lõi: Cập nhật Vận tốc và Cập nhật Vị trí. Cơ sở toán học này mô tả cách mỗi "hạt" (tương ứng với mỗi cá thể chim trong đàn) trong bầy đàn điều chỉnh chuyển động của nó qua không gian tìm kiếm.

\subsubsection{Phương trình Cập nhật Vận tốc (Velocity Update)}
Phương trình này tính toán vận tốc mới (véc-tơ di chuyển) cho một hạt ở vòng lặp (thế hệ) tiếp theo. Vận tốc mới được quyết định bởi ba thành phần:
\begin{itemize}
    \item \textbf{Quán tính (Inertia):} Vận tốc hiện tại của hạt, giữ cho nó di chuyển theo hướng cũ.
    \item \textbf{Thành phần Nhận thức (Cognitive Component):} Hướng di chuyển về phía vị trí tốt nhất cá nhân (pbest) mà hạt đó đã từng đạt được.
    \item \textbf{Thành phần Xã hội (Social Component):} Hướng di chuyển về phía vị trí tốt nhất toàn bầy (gbest) mà bất kỳ hạt nào trong bầy đã từng đạt được.
\end{itemize}

Công thức toán học như sau:
\begin{equation}
    \mathbf{v}_{i}(t+1) = w \cdot \mathbf{v}_{i}(t) + c_1 \cdot r_1 \cdot (\mathbf{pbest}_{i} - \mathbf{x}_{i}(t)) + c_2 \cdot r_2 \cdot (\mathbf{gbest} - \mathbf{x}_{i}(t))
\end{equation}

Trong đó:
\begin{itemize}
    \item $ \mathbf{v}_{i}(t+1) $: Là vận tốc mới (dự kiến) của hạt $i$ tại vòng lặp $t+1$.
    \item $ w $: \textbf{Trọng số quán tính (Inertia weight)}.
    \item $ \mathbf{v}_{i}(t) $: Vận tốc hiện tại của hạt $i$ tại vòng lặp $t$.
    \item $ c_1, c_2 $: \textbf{Hệ số học tập (Learning coefficients)} (hằng số gia tốc).
    \item $ r_1, r_2 $: Là hai số ngẫu nhiên được tạo ra trong khoảng $[0, 1]$.
    \item $ \mathbf{pbest}_{i} $: Vị trí tốt nhất mà cá nhân hạt $i$ đã tìm thấy.
    \item $ \mathbf{gbest} $: Vị trí tốt nhất mà cả bầy đàn đã tìm thấy.
    \item $ \mathbf{x}_{i}(t) $: Vị trí hiện tại của hạt $i$ tại vòng lặp $t$.
\end{itemize}

\subsubsection{Phương trình Cập nhật Vị trí (Position Update)}
Sau khi tính toán vận tốc mới, hạt sẽ sử dụng vận tốc đó để di chuyển đến một vị trí mới trong không gian tìm kiếm.

Công thức toán học như sau:
\begin{equation}
    \mathbf{x}_{i}(t+1) = \mathbf{x}_{i}(t) + \mathbf{v}_{i}(t+1)
\end{equation}

Trong đó:
\begin{itemize}
    \item $ \mathbf{x}_{i}(t+1) $: Là vị trí mới của hạt $i$ tại vòng lặp $t+1$.
    \item $ \mathbf{x}_{i}(t) $: Vị trí hiện tại của hạt $i$ tại vòng lặp $t$.
    \item $ \mathbf{v}_{i}(t+1) $: Vận tốc mới vừa được tính toán từ phương trình (1).
\end{itemize}

\subsection{Triển khai thuật toán}

\subsubsection{Cách hoạt động của thuật toán}
Thuật toán PSO mô phỏng một bầy đàn "bay"  qua không gian tìm kiếm để tìm giải pháp tối ưu.

\begin{algorithm}
\caption{Thuật toán Tối ưu hóa Bầy đàn Hạt (PSO)}
\label{alg:pso_algorithm}
\begin{algorithmic}[1]
    \STATE \textbf{[PHẦN 1: KHỞI TẠO]}
    \STATE Khởi tạo một bầy đàn (population) gồm $N$ hạt.
    \FOR{mỗi hạt $i$ (từ 1 đến $N$)}
        \STATE Khởi tạo vị trí ban đầu $\mathbf{x}_i$ (ngẫu nhiên).
        \STATE Khởi tạo vận tốc ban đầu $\mathbf{v}_i$ (bằng 0).
        \STATE Tính giá trị thích nghi (fitness) $f(\mathbf{x}_i)$.
        \STATE $\mathbf{pbest}_i \leftarrow \mathbf{x}_i$
    \ENDFOR
    \STATE $\mathbf{gbest} \leftarrow$ hạt có giá trị thích nghi tốt nhất trong bầy.
\end{algorithmic}
\end{algorithm}
\pagebreak
\begin{algorithm}
\caption{Thuật toán Tối ưu hóa Bầy đàn Hạt (PSO) (cont.)}
\begin{algorithmic}[1]
\ContinuedFloat 
    \STATE \textbf{[PHẦN 2: VÒNG LẶP CHÍNH]}
    \WHILE{chưa đạt điều kiện dừng (ví dụ: $t < T_{\text{max}}$)}
        \FOR{mỗi hạt $i$ (từ 1 đến $N$)}
            \COMMENT{Cập nhật Vận tốc theo phương trình (1)}
            \STATE $\mathbf{v}_{i}(t+1)$
            
            \COMMENT{Cập nhật Vị trí theo phương trình (2)}
            \STATE $\mathbf{x}_{i}(t+1) \leftarrow \mathbf{x}_{i}(t) + \mathbf{v}_{i}(t+1)$
            
            \COMMENT{Đánh giá vị trí mới}
            \STATE Tính $f(\mathbf{x}_{i}(t+1))$
            
            \COMMENT{Cập nhật pbest (bộ nhớ cá nhân)}
            \IF{$f(\mathbf{x}_{i}(t+1))$ tốt hơn $f(\mathbf{pbest}_i)$}
                \STATE $\mathbf{pbest}_i \leftarrow \mathbf{x}_{i}(t+1)$
            \ENDIF
            
            \COMMENT{Cập nhật gbest (bộ nhớ bầy đàn)}
            \IF{$f(\mathbf{x}_{i}(t+1))$ tốt hơn $f(\mathbf{gbest})$}
                \STATE $\mathbf{gbest} \leftarrow \mathbf{x}_{i}(t+1)$
            \ENDIF
        \ENDFOR
    \ENDWHILE
    
    \STATE \textbf{TRẢ VỀ:} $\mathbf{gbest}$ (Vị trí của giải pháp tốt nhất)
\end{algorithmic}
\end{algorithm}

\subsubsection{Triển khai kỹ thuật}
\begin{itemize}
    \item \textbf{Ngôn ngữ:} Python
    \item \textbf{Các thư viện sử dụng:} numpy, random, matplotlib
    \item \textbf{Các class:}
    \begin{itemize}
        \item Class \texttt{PSO\_Solver}: chứa các hàm chính để giải bài toán và kiểm thử trên tập dữ liệu cho trước.
        \item Class \texttt{Agent}: triển khai một giải pháp tiềm năng cho bài toán.
    \end{itemize}
    \item Chi tiết triển khai ở github repository (nằm trong phần phụ lục).
\end{itemize}

\section{Artificial Bee Colony}
% Các phần của báo cáo
\subsection{Giới thiệu thuật toán} \cite{karaboga2009comparative}

Thuật toán đàn ong nhân tạo (Artificial Bee Colony - ABC) được đề xuất bởi Derviş Karaboğa (2005), mô phỏng hành vi tìm kiếm và chia sẻ thông tin về nguồn mật hoa của đàn ong mật trong tự nhiên. Mục tiêu là tìm lời giải tốt nhất cho bài toán tối ưu hóa bằng cách mô phỏng quá trình ong tìm mật. Trong đồ án này, bài toán được sử dụng là tìm giá trị nhỏ nhất của hàm số 2 biến.

\subsection{Ý tưởng thuật toán và nguyên lý hoạt động}
Trong tự nhiên, ong mật chia thành 3 nhóm: ong thợ, ong quan sát và ong trinh sát. Nhiệm vụ của mỗi nhóm như sau:

\begin{itemize}
    \item Ong thợ tìm kiếm thức ăn xung quanh nguồn mật bằng trí nhớ, đồng thời chia sẻ thông tin về những nguồn mật này cho ong quan sát. 
    
    \item Ong quan sát có xu hướng chọn nguồn mật tốt từ những nguồn mà ong thợ tìm thấy. Nguồn mật có chất lượng cao hơn (độ thích nghi cao) sẽ có nhiều khả năng được ong quan sát lựa chọn hơn. 
    
    \item Khi nguồn mật đã cạn, ong do thám sẽ bỏ nguồn mật hiện tại và tìm kiếm nguồn mới ngẫu nhiên.

\end{itemize}

Ong thợ và ong quan sát tìm kiếm các nguồn mật xung quanh tổ. Những con ong thợ lưu trữ thông tin về nguồn mật và chia sẻ thông tin với những con ong quan sát. Số lượng nguồn mật bằng với số lượng ong thợ. Một con ong thợ sau khi khai thác một nguồn một số lần nhất định mà chất lượng nguồn mật của chúng không thể cải thiện, nó sẽ trở thành ong trinh sát và bỏ nguồn mật cũ đi. Tương tự trong bài toán tối ưu hóa, số lượng nguồn mật trong thuật toán ABC đại diện cho số lượng chất lượng nguồn mật trong quần thể (càng nhiều mật thì chất lượng mật càng tốt và ngược lại). Nói cách khác, nếu các con ong tìm được một nguồn mật tốt, đây có khả năng sẽ là điểm tối ưu và sẽ có xu hướng thu hút các con ong khác tới khai thác.

\subsection{Giải thích cơ chế hoạt động bằng công cụ toán học}

\subsubsection{Ký hiệu và các tham số chính}
\begin{itemize}
    \item $\textbf{f(x)}$: Hàm mục tiêu cần tối ưu hoá
    \item $\textbf{SN}$: Số lượng ong thợ (cũng bằng số nguồn mật)
    \item $\textbf{limit}$: Giới hạn số lần không cải thiện trước khi ong thợ trở thành ong do thám (để đi tìm nguồn mật tốt hơn), tránh trường hợp các con ong "quanh quẩn" ở điểm tối ưu cục bộ, nơi có nguồn mật tốt hơn so với các nguồn xung quanh nhưng không phải nguồn mật tốt nhất có thể khai thác.
    \item $\textbf{maxCycle}$: Số vòng lặp tối đa, nếu sau maxCycle lần khai thác và tìm kiếm, các con ong vẫn tập trung tại một nguồn mật nào đó, điểm này sẽ được xác định là điểm tối ưu, dừng thuật toán.
\end{itemize}

\subsubsection{Nguyên lý}

Thuật toán ABC gồm 4 giai đoạn chính như sau: \cite{kumar2013review}

\begin{enumerate}
    \item \textbf{Khởi tạo quần thể}
    
    Ban đầu tất cả $SN$ ong trong quần thể sẽ là ong do thám, khi đó tương ứng $SN$ nguồn mật sẽ được sinh ra ngẫu nhiên trong không gian tìm kiếm điểm tối ưu. Mỗi nguồn mật (ký hiệu bởi $x_m$) là một vector có $D$ chiều, là số chiều của không gian tìm kiếm, được sinh bởi công thức:
    \begin{equation*}
        x_{m} = l_i + rand(0, 1) \times (u_i - l_i)
    \end{equation*}
    với $u_i$ và $l_i$ lần lượt là cận trên và cận dưới của không gian tìm kiếm, $rand(0, 1)$ là một số ngẫu nhiên thuộc đoạn $[0, 1]$
    
    \item \textbf{Pha ong thợ}
    
    Từ nguồn mật hiện tại $x_i$, ong thợ bay đến một nguồn mật $v_i$ khác trong khu vực lân cận. So sánh giá trị của $f(x_i)$ và $f(v_i)n$, nếu nguồn mật chất lượng hơn (giá trị hàm đạt được tại $v_i$ tốt hơn) sẽ thay thế cho nguồn cũ. Giá trị của mỗi chiều của $v_i$ được sinh bởi công thức:
    $$
    v_{ij} = x_{ij} + \phi_{ij}(x_{ij} - x_{kj})
    $$
    Trong đó $j = \overline{1..D}$, $\phi_{m}$ là một số ngẫu nhiên thuộc đoạn $[-1, 1]$

    \item \textbf{Pha ong quan sát}
    Mỗi ong quan sát chọn nguồn mật dựa trên xác suất được tính bởi phương trình:

    $$
    p_i = \frac{fit_i}{\displaystyle \sum_{j=1}^{SN} fit_j}
    $$
    
    Với $fit_i$ là độ phù hợp của từng nguồn mật, được tính theo công thức:
    $$
    fit_i =
    \begin{cases}
        \frac{1}{1 + f(x_i)}, & f(x_i) \ge 0 \\
        1 + |f(x_i)|, & f_(x_i) < 0
    \end{cases}
    $$

    Sau khi chọn, ong quan sát cũng tạo nguồn mật mới theo công thức tương tự như ở pha ong thợ. Nếu tốt hơn, cập nhật nguồn mật tương ứng.
    
    \item \textbf{Pha ong do thám}
    Nếu một nguồn mật không được cải thiện sau $limit$ lần, ong thợ sẽ bỏ nguồn mật này đi và trở thành ong do thám. Sau đó, chúng sẽ tạo nguồn mật mới ngẫu nhiên bằng công thức như ở pha khởi tạo quần thể:

    \item \textbf{Lặp lại}

    Lặp lại các pha 2 đến 4 cho đến khi đạt số vòng lặp $maxCycle$ hoặc đạt tiêu chí hội tụ (không còn cải thiện) 
\end{enumerate}

\subsubsection{Mã giả (Pseudo-code) thuật toán ABC} \cite{ibrahim2025artificial}

\begin{algorithm} [H]
\begin{algorithmic}[1]
\STATE Khởi tạo quần thể gồm $SN$ nguồn thức ăn $x_i$ ($i = 1,2,\dots,SN$)
\STATE Đánh giá độ thích nghi (fitness) của từng nguồn thức ăn
\REPEAT
    \FOR{mỗi ong thợ}
        \STATE Sinh ra ứng viên mới $v_i$ lân cận $x_i$
        \STATE Đánh giá độ thích nghi của $v_i$
        \STATE Lựa chọn giữa $x_i$ và $v_i$ 
    \ENDFOR
    \FOR{mỗi ong quan sát}
        \STATE Chọn nguồn thức ăn $x_i$ với xác suất tỉ lệ thuận với độ thích nghi của nó
        \STATE Sinh ra ứng viên mới $v_i$
        \STATE Lựa chọn giữa $x_i$ và $v_i$ 
    \ENDFOR
    \STATE Nếu một nguồn thức ăn không được cải thiện sau một số vòng lặp giới hạn, thay thế bằng một nguồn ngẫu nhiên mới (giai đoạn ong do thám)
    \STATE Ghi nhớ nghiệm tốt nhất hiện tại
\UNTIL{thoả mãn điều kiện dừng}
\end{algorithmic}
\end{algorithm}


\section{Firefly Algorithm}

\section{Cuckoo Search}
\subsection{Giới thiệu thuật toán}
Cuckoo Search (CS) là một thuật toán metaheuristic được đề xuất bởi Xin-She Yang và Suash Deb vào năm 2009. Thuật toán lấy cảm hứng từ hành vi sinh sản ký sinh của loài chim cu (cuckoo), kết hợp với cơ chế Lévy flight để khám phá không gian tìm kiếm hiệu quả.

Cuckoo Search thuộc nhóm \textit{Swarm Intelligence} tương tự như PSO hay ABC, với ý tưởng là mỗi cá thể (tổ chim) đại diện cho một nghiệm ứng viên trong không gian tìm kiếm. Quá trình tiến hóa xảy ra thông qua việc các tổ chim được thay thế dần bằng các nghiệm tốt hơn.

\subsection{Ý tưởng thuật toán}
Mỗi con chim cu đẻ trứng vào tổ của các loài chim khác. Nếu trứng bị phát hiện là “kẻ lạ”, chủ tổ sẽ loại bỏ trứng đó hoặc bỏ tổ và xây tổ mới. Cuckoo Search mô phỏng hành vi này bằng cách:
\begin{itemize}
    \item Mỗi “tổ” đại diện cho một nghiệm trong không gian tìm kiếm.
    \item Một số trứng (nghiệm) mới được tạo ra thông qua Lévy flight từ các tổ hiện tại.
    \item Một tỷ lệ $p_a$ các tổ xấu nhất sẽ bị loại bỏ và thay bằng các tổ mới ngẫu nhiên.
    \item Tổ tốt nhất được giữ lại qua các thế hệ.
\end{itemize}

\subsection{Cơ sở toán học của thuật toán}
Giả sử không gian tìm kiếm có $d$ chiều và $n$ tổ chim. Mỗi tổ $x_i = [x_{i1}, x_{i2}, \ldots, x_{id}]$ tương ứng với một nghiệm.  
Tại mỗi vòng lặp, tổ mới được tạo ra theo công thức:
\begin{equation}
    x_i^{(t+1)} = x_i^{(t)} + \alpha \cdot \text{Levy}(\beta)
\end{equation}
Trong đó:
\begin{itemize}
    \item $\alpha$ là hệ số bước bay (step size),
    \item $\text{Levy}(\beta)$ là bước nhảy theo phân phối Lévy với tham số $\beta$ (thường $\beta = 1.5$).
\end{itemize}

Phân phối Lévy được sinh ra theo công thức Mantegna:
\begin{equation}
    s = \frac{u}{|v|^{1/\beta}}, \quad
    u \sim N(0, \sigma_u^2), \quad
    v \sim N(0, 1)
\end{equation}
với
\begin{equation}
    \sigma_u = \left[ \frac{\Gamma(1+\beta)\sin(\pi \beta/2)}
    {\Gamma((1+\beta)/2) \beta 2^{(\beta-1)/2}} \right]^{1/\beta}
\end{equation}

Sau mỗi lần cập nhật, các tổ bị phát hiện (với xác suất $p_a$) sẽ bị thay thế ngẫu nhiên:
\begin{equation}
    x_i^{(t+1)} = x_i^{(t)} + r \cdot (x_j^{(t)} - x_k^{(t)}),
\end{equation}
trong đó $x_j, x_k$ là hai tổ ngẫu nhiên khác nhau, và $r$ là một số ngẫu nhiên trong $[0,1]$.

\subsection{Triển khai thuật toán}
\subsubsection{Cách hoạt động của thuật toán}
\begin{enumerate}
    \item \textbf{Khởi tạo quần thể:} Tạo $n$ tổ ngẫu nhiên trong không gian tìm kiếm.
    \item \textbf{Đánh giá:} Tính giá trị hàm mục tiêu (fitness) của từng tổ.
    \item \textbf{Bay Lévy:} Tạo các tổ mới bằng cách bay Lévy từ các tổ hiện tại.
    \item \textbf{Cập nhật:} Nếu tổ mới tốt hơn, thay thế tổ cũ.
    \item \textbf{Phát hiện trứng lạ:} Với xác suất $p_a$, thay thế các tổ tệ nhất bằng tổ mới ngẫu nhiên.
    \item \textbf{Ghi nhận nghiệm tốt nhất:} Cập nhật tổ có giá trị hàm mục tiêu nhỏ nhất.
    \item \textbf{Lặp lại} cho đến khi đạt số vòng lặp tối đa hoặc hội tụ.
\end{enumerate}

\subsubsection{Mã giả }
\begin{algorithm}[H]
\caption{Thuật toán Cuckoo Search}
\begin{algorithmic}[1]
\STATE Khởi tạo $n$ tổ $x_i$ ngẫu nhiên trong không gian tìm kiếm
\STATE Đánh giá giá trị hàm mục tiêu $f(x_i)$ cho mỗi tổ
\FOR{$t = 1$ đến $T_{max}$}
    \STATE \textbf{(Pha 1: Lévy flight)}\\
    \FOR{mỗi tổ $x_i$}
        \STATE Sinh bước Lévy $s \sim \text{Levy}(\beta)$
        \STATE $x_i' = x_i + \alpha \cdot s$
        \STATE Nếu $f(x_i') < f(x_i)$ thì cập nhật $x_i = x_i'$
    \ENDFOR
    \STATE \textbf{(Pha 2: Phát hiện trứng)}\\
    \STATE Chọn ngẫu nhiên một phần $p_a$ các tổ tệ nhất
    \STATE Thay thế chúng bằng tổ mới ngẫu nhiên trong không gian tìm kiếm
    \STATE Cập nhật tổ tốt nhất hiện tại
\ENDFOR
\STATE Xuất ra nghiệm tốt nhất tìm được
\end{algorithmic}
\end{algorithm}


\section{Các thuật toán truyền thống để so sánh}
\subsection{Genetic Algorithm}
\subsubsection{Giới thiệu chung}


Genetic Algorithm (GA - Giải thuật di truyền) là một kĩ thuật tìm kiếm nhằm tìm ra đáp án gần đúng trong các bài toán tối ưu hóa mô hình và bài toán tìm kiếm. GA được xem là một trong những metaheuristic phổ biến và được ứng dụng nhiều nhất.


Trong một quần thể trong tự nhiên, các loài sinh vật phải thích nghi và thay đổi qua từng thế hệ để có thể sinh tồn, đó gọi là sự tiến hóa (theo học thuyết tiến hóa của Darwin). Ở hình trên, các con hươu cao cổ thông qua một cơ chế tiến hóa gọi là chọn lọc tự nhiên, những con thấp sẽ không thể ăn lá và chết dần, qua thời gian dài chỉ còn lại những con cao hơn tiếp tục sinh sản và phát triển quần thể. Như vậy, các loài sinh vật luôn phải tiến hóa để tránh bị đào thải trong môi trường tự nhiên khắc nghiệt.


GA được phát minh bởi John Holland và các cộng sự tại đại học Michigan vào những năm 1960, dựa trên các nguyên tắc của tiến hóa, bao gồm các quá trình lai tạo (crossover), đột biến (mutation) và chọn lọc (selection). Nó bắt đầu phổ biến vào những năm 1990, khi người ta bắt đầu tìm kiếm những công cụ heuristic để giải quyết những bài toán mà giải thuật chính xác không khả thi.


Thuật giải GA đã và đang được ứng dụng để giải quyết các bài toán trong rất nhiều lĩnh vực của cuộc sống cũng như trong kỹ thuật, ví dụ như tối ưu hóa, học máy, ….


\begin{figure}[h]
\centering
% Thay thế đường dẫn ảnh nếu bạn có file ảnh. Hiện đặt tên tệp mẫu: ck12_giraffe.png
\includegraphics[width=0.6\textwidth]{giraffe.png}
\caption{ Quá trình tiến hóa của hươu cao cổ (Ảnh: CK-12 Foundation)}
\end{figure}


\subsubsection{Cơ sở toán học}

\paragraph{Không gian nghiệm và mã hoá.}
Gọi $\mathcal{C}$ là không gian các nhiễm sắc thể (chromosomes). Một nhiễm sắc thể thường được biểu diễn là một chuỗi ký tự có độ dài $l$:
\[ c = (c_1,c_2,\dots,c_l) \in \{0,1\}^l \quad \text{hoặc} \quad c\in \mathbb{R}^l \]
Mỗi nhiễm sắc thể $c$ tương ứng với một \emph{phenotype} (lời giải) thông qua một ánh xạ giải mã $\phi:\mathcal{C}\to\mathcal{X}$. Hàm đánh giá (fitness) là
\[ F:\mathcal{C}\to\mathbb{R},\qquad F(c)\text{ là mức "tốt" của lời giải }c.\]


\paragraph{Chọn lọc (Selection).}
Một phương pháp phổ biến là chọn theo tỉ lệ fitness (roulette-wheel). Nếu quần thể hiện tại có $N$ cá thể $c^{(1)},\dots,c^{(N)}$ thì xác suất chọn cá thể $i$ là:
\begin{equation}\label{eq:roulette}
p_i = \frac{F(c^{(i)})}{\sum_{j=1}^N F(c^{(j)})}.
\end{equation}

\paragraph{Schema và Schema Theorem.}
Một \emph{schema} $H$ là một mẫu cố định trên một số vị trí của nhiễm sắc thể, ký hiệu bằng chuỗi trong bảng chữ cái $\{0,1,*\}$ ("*" là wildcard). Đặt:
\begin{itemize}
\item $m_H(t)$: số cá thể thuộc schema $H$ ở thế hệ $t$;
\item $\bar F_H(t)$: độ fitness trung bình của các cá thể trong $H$;
\item $\bar F(t)$: độ fitness trung bình toàn quần thể;
\item $F_H(t)=\dfrac{\bar F_H(t)}{\bar F(t)}$ là \emph{relative fitness} của schema $H$;
\item $l_H$ là khoảng cách giữa gene đầu và gene cuối được cố định trong $H$ (schema length);
\item $o_H$ là order của $H$ (số bit cố định trong schema);
\item $p_c$ là xác suất crossover, $p_m$ là xác suất mutation (tại mỗi locus).
\end{itemize}


Schema Theorem (dạng bất đẳng thức cho kì vọng):
\begin{equation}\label{eq:schema}
\mathbb{E}[m_H(t+1)] \ge F_H(t)\, m_H(t)\, \Big(1 - p_c\frac{l_H}{l-1}\Big)\,(1-p_m)^{o_H}.
\end{equation}


Ý nghĩa: những schema ngắn, có ít bit cố định (nhỏ $o_H$), và có relative fitness $F_H(t)>1$ sẽ có xu hướng gia tăng trong quần thể. Đây là cơ sở trực giác cho "building-block hypothesis": GA kết hợp những phần tốt (building blocks) từ nhiều cá thể để tạo ra lời giải tốt hơn.



\paragraph{Các tham số quan trọng (toán học).}
\begin{itemize}
\item Kích thước quần thể $N$: quyết định độ phong phú mẫu cho phân phối; quá nhỏ dễ mất đa dạng.
\item Xác suất crossover $p_c$ và mutation $p_m$: ảnh hưởng cân bằng khám phá/khai thác.
\item Cost đánh giá fitness: độ phức tạp tính toán thường là $\mathcal{O}(N\cdot \text{cost\_eval}\cdot G)$ với $G$ là số thế hệ.
\end{itemize}

\subsubsection{Cách hoạt động của thuật toán}

\paragraph{Các toán tử chính.}
\begin{itemize}
\item \textbf{Selection:} Lấy mẫu theo phân phối $p_i$ như (\ref{eq:roulette}) hoặc dùng tournament selection.
\item \textbf{Crossover:} Cho hai cha mẹ $c^{(a)}$ và $c^{(b)}$. Với 1-point crossover tại vị trí $k$ (1\le k < l), sinh con:
\[ c^{(child)} = (c^{(a)}_1,\dots,c^{(a)}_k,\, c^{(b)}_{k+1},\dots,c^{(b)}_l). \]
\item \textbf{Mutation:} Với mỗi locus, thực hiện biến đổi theo Bernoulli($p_m$). Với mã hóa bit-string, mutation là bit-flip.
\item \textbf{Elitism:} Giữ lại $e$ cá thể tốt nhất sang thế hệ sau để tránh mất nghiệm tốt do tính ngẫu nhiên.
\end{itemize}

\begin{algorithm}[H]
\caption{Genetic Algorithm (GA)}
\begin{algorithmic}[1]
\State \textbf{Input:} kích thước quần thể $N$, chiều dài NST $l$, xác suất crossover $p_c$, xác suất mutation $p_m$, số thệ hệ tối đa $G$, elitism $e$.
\State Khởi tạo quần thể $P^0 = \{c^{(1)},\dots,c^{(N)}\}$ (thường ngẫu nhiên).
\For{$t=0$ to $G-1$}
\State Tính $F(c)$ cho mọi $c\in P^t$.
\State Sao chép $e$ cá thể tốt nhất sang $P^{t+1}$ (elitism).
\While{size($P^{t+1}$) $<$ $N$}
\State Chọn cặp cha mẹ theo selection (ví dụ roulette hoặc tournament).
\State Với xác suất $p_c$, áp dụng crossover để sinh 1 hoặc 2 con; ngược lại sao chép cha mẹ.
\State Áp dụng mutation cho từng con với xác suất $p_m$ trên mỗi locus.
\State Thêm con vào $P^{t+1}$.
\EndWhile
\EndFor
\State Trả về cá thể tốt nhất tìm được.
\end{algorithmic}
\end{algorithm}

\section{Các bài toán sử dụng để đánh giá}
\subsection{Các bài toán rời rạc}
\subsubsection{The travelling salesman problem}
\textbf{Giới thiệu chung}

The travelling saleman problem (TSP) là một bài toán kinh điển trong lý thuyết đồ thị và có rất nhiều ứng dụng trong thực tế và kĩ thuật.

Bài toán yêu cầu tìm ra tuyến đường ngắn nhất để một người đi qua tất cả các thành phố được cho, mỗi thành phố chỉ ghé thăm đúng một lần, và quay trở lại điểm xuất phát ban đầu.

Nó có thể được phát biểu dưới dạng đồ thị như sau: Cho một đồ thị vô hướng có trọng số, tìm chu trình ngắn nhất xuất phát từ một đỉnh bất kì, đi qua tất cả các đỉnh đúng một lần và quay về điểm xuất phát (chu trình hamilton ngắn nhất). Đây là một bài toán NP-hard, có thể hiểu đơn giản là chúng ta chưa thể tìm ra lời giải đa thức chính xác cho bài toán này. Vì vậy, các phương pháp metaheuristic được đưa ra nhằm tìm ra lời giải chính xác gần đúng trong thời gian hợp lý.

Bài toán được ứng dụng rộng rãi trong các lĩnh vực của kĩ thuật và đời sống, đặc biệt là các bài toán tối ưu hóa như lập kế hoạch, lập lịch trình, hậu cần, đóng gói,...

% (Ảnh : Gate Vidyalay)
\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{tsp.png}
\caption{Minh họa TSP (nguồn: Gate Vidyalay)}
\end{figure}

\textbf{Những thuật toán áp dụng}

\textbf{ACO}

ACO (Ant Colony Optimization) là một metaheuristic phù hợp cho các bài toán đồ thị, đặc biệt là TSP. 

\textbf{PSO}

PSO (Particle Swarm Optimization) vốn thiết kế cho bài toán liên tục nhưng có thể điều chỉnh cho TSP bằng cách biểu diễn \emph{thứ tự các thành phố} (permutation) là vị trí của từng hạt và biểu diễn vận tốc bằng các thao tác hoán vị (swap).

\textit{Tóm tắt cách PSO hoạt động trong TSP:}
\begin{enumerate}
  \item Mỗi hạt lưu một \texttt{route} (một hoán vị — chuỗi các chỉ số thành phố, bắt đầu và kết thúc tại 0).
  \item Đánh giá độ phù hợp (fitness) của mỗi route bằng tổng khoảng cách giữa các cặp liên tiếp (dùng ma trận khoảng cách hoặc tính từ tọa độ).
  \item Cập nhật ``vận tốc'' dưới dạng danh sách các cặp hoán đổi (swaps) dựa trên 3 thành phần: \emph{inertia} (w) giữ một phần vận tốc cũ, \emph{cognitive} (c1) hướng về personal best, và \emph{social} (c2) hướng về global best.
  \item Áp dụng các swap lên route để tạo route mới; nếu cần, thực hiện reshuffle (xáo trộn) để tăng khám phá.
  \item Lặp lại cho đến khi đạt điều kiện dừng (số iter, hội tụ, v.v.).
\end{enumerate}

\underline{Swap operation}
\begin{itemize}
  \item \textit{Định nghĩa:} Một \emph{swap} là thao tác hoán đổi hai vị trí trong chuỗi route, ví dụ swap$(i,j)$ sẽ hoán đổi phần tử ở chỉ số $i$ với phần tử ở chỉ số $j$ trong route.
  \item \textit{Ý nghĩa:} Mỗi swap thay đổi thứ tự thăm các thành phố, do đó có thể làm tăng hoặc giảm tổng chiều dài chuyến đi. Dùng tập hợp các swap (vận tốc rời rạc) để biểu diễn hướng di chuyển của một hạt trong không gian hoán vị.
  \item \textit{Cách áp dụng trong PSO rời rạc:}
    \begin{enumerate}
      \item Xây danh sách swap mới (kết hợp giữ lại một phần swap cũ theo \emph{inertia}, thêm swap do \emph{personal best} và swap do \emph{global best}).
      \item Áp từng swap (theo thứ tự) lên route hiện tại: với mỗi $(a,b)$ thực hiện hoán đổi phần tử tại vị trí $a$ và $b$.
      \item Đảm bảo sau khi áp swap, route vẫn là một hoán vị hợp lệ (không xuất hiện đỉnh trùng lặp) — thao tác swap nguyên thủy luôn giữ tính hợp lệ vì chỉ hoán đổi vị trí giữa hai thành phần.
    \end{enumerate}
\end{itemize}

\textbf{Genetic Algorithm (GA)}
GA là thuật toán truyền thống dùng so sánh với ACO và PSO. GA thường thao tác trên biểu diễn nhiễm sắc (genotype) — ví dụ tọa độ thực của các thành phố hoặc hoán vị — và dùng các toán tử lai ghép (crossover), đột biến (mutation) để tìm kiếm. Trong đề tài này, GA có thể nhận tọa độ thực của thành phố làm đầu vào, sau đó chuyển sang ma trận khoảng cách để so sánh với ACO/PSO.

\subsection{Các bài toán liên tục}
Để đánh giá hiệu quả của các thuật toán, nhóm tiến hành thử nghiệm trên một tập các bài toán tối ưu liên tục chuẩn thường được sử dụng trong lĩnh vực tối ưu metaheuristic. Các hàm này có đặc điểm đa dạng về độ lồi, số lượng cực trị và độ phức tạp, giúp đánh giá khả năng hội tụ toàn cục và cục bộ của thuật toán.

\begin{itemize}
    \item \textbf{Sphere function}:
    \[
    f(x) = \sum_{i=1}^d x_i^2, \quad x_i \in [-5.12, 5.12]
    \]
    Đây là hàm đơn giản, lồi và có nghiệm tối ưu toàn cục tại $x = 0$, $f_{min} = 0$.

    \item \textbf{Rosenbrock function}:
    \[
    f(x) = \sum_{i=1}^{d-1} [100(x_{i+1} - x_i^2)^2 + (x_i - 1)^2]
    \]
    Hàm phi tuyến, có rãnh hẹp dẫn đến cực tiểu toàn cục tại $x = (1, 1, \ldots, 1)$.

    \item \textbf{Rastrigin function}:
    \[
    f(x) = 10d + \sum_{i=1}^d [x_i^2 - 10\cos(2\pi x_i)]
    \]
    Hàm có nhiều cực trị cục bộ, được dùng để kiểm tra khả năng thoát bẫy cục bộ của thuật toán.

\end{itemize}

\section{Phân tích kết quả bài toán}

\section{Phân tích so sánh và kết luận}

\section*{Phân công công việc}
\addcontentsline{toc}{section}{\protect\numberline{}Phân công công việc}

\section*{Phụ lục}
\addcontentsline{toc}{section}{\protect\numberline{}Phụ lục}

\bibliographystyle{alpha}
\bibliography{references}

\subsection*{Source code}

\end{document}